<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "../../../target/docbook-tool-1.0/docbook-xml/docbookx.dtd">

<chapter id="bpmn20">
	<title>BPMN</title>

	<section id="whatIsBpmn">

		<title>What is BPMN?</title>

		<para>
		  See our <ulink url="http://activiti.org/faq.html#WhatIsBpmn20">FAQ entry on BPMN 2.0</ulink>.
		</para>

	</section>

	<section id="bpmnExamples">

		<title>Examples</title>

		<para>
		  Examples for the BPMN 2.0 constructs described in the following sections can be 
		  found in the <emphasis>workspace/activiti-x-examples</emphasis> folders of the Activiti distribution. 
	  </para>
	  
	  <para>	  
		  See the specific section on <link linkend="examples">examples</link> for more information.
		</para>

	</section>

	<section id="bpmnDefiningProcess">

		<title>Defining a process</title>

		<para>
      To create a new BPMN 2.0 process definition, it's best to have your Eclipse
      <link linkend="eclipsesetup">properly set up</link>.		  
		</para>
		
		<para>
		  Create a new XML file (<emphasis>rightclick on any project and select New->Other->XML-XML File</emphasis>) and give it a name.
		  Make sure that the file <emphasis role="bold">ends with .bpmn20.xml</emphasis>, since
		  otherwise the engine won't pick up this file for deployment.
		  <mediaobject><imageobject><imagedata align="center" fileref="images/new.bpmn.procdef.png"/></imageobject></mediaobject>
		</para>
		
		<para>
		  The root element of the BPMN 2.0 schema is the <emphasis role="bold">definitions</emphasis> element.
		  Within this element, multiple process definitions can be defined (although we advise to have only one
		  process definition in each file, since this simplifies maintenance later in the development process).
		  An empty process definition looks as follows. Note that the minimal definitions element
		  only needs the <emphasis>xmlns</emphasis> and <emphasis>targetNamespace</emphasis> declaration.
		  The targetNamespace can be anything, and is useful for categorizing process definitions.
		  <programlisting>
&lt;definitions 
  xmlns=&quot;http://www.omg.org/spec/BPMN/20100524/MODEL&quot;
  xmlns:activiti=&quot;http://activiti.org/bpmn&quot;
  targetNamespace=&quot;Examples&quot;&gt;

  &lt;process id=&quot;myProcess&quot; name=&quot;My First Process&quot;&gt;
    ..
  &lt;/process&gt;

&lt;/definitions&gt;</programlisting>
		</para>
		
		<para>
		  The process element has two attributes:
		  <itemizedlist>
		    <listitem>
		      <para>
		        <emphasis role="bold">id</emphasis>: this attribute is <emphasis role="bold">required</emphasis>
		        and maps to the <emphasis role="bold">key</emphasis> property of an Activiti <emphasis>
		        ProcessDefinition</emphasis> object.
		        This id can then be used to start a new process instance of the process definition, through the 
		        <emphasis>startProcessInstanceByKey</emphasis> method on the <literal>RuntimeService</literal>.
		        This method will always take the <emphasis role="bold">latest deployed version</emphasis>
		        of the process definition.
		        <programlisting>ProcessInstance processInstance = runtimeService.startProcessInstanceByKey("myProcess");</programlisting>
		        Important to note here is that this is not the same as calling the 
		        <emphasis>startProcessInstanceById</emphasis> method. This method expects the String id 
		        that was generated at deploy time by the Activiti engine, and can be retrieved by calling the
		        <emphasis>processDefinition.getId()</emphasis> method.
		        The format of the generated id is <emphasis role="bold">'key:version'</emphasis>, 
		        and the length is <emphasis role="bold">constrained to 64 characters</emphasis>.
		        If you get an <emphasis>ActivitiException</emphasis> stating that the generated id
		        is too long, limit the text in the <emphasis>key</emphasis> field of the process.
		      </para>
		    </listitem>
		    <listitem>
          <para>
            <emphasis role="bold">name</emphasis>: this attribute is <emphasis role="bold">optional</emphasis>
            and maps to the <emphasis>name</emphasis> property of a <emphasis>ProcessDefinition</emphasis>.
            The engine itself doesn't use this property, so it can for example be used for displaying a more
            human-friendly name in a user interface.
          </para>
        </listitem>
		  </itemizedlist>
		</para>

	</section>
	
	<section id="10minutetutorial">
	
    <title>Getting started: 10 minute tutorial</title>
    
    <para>
      In this section we will cover a (very simple) business process that we will use to introduce
      some basic Activiti concepts and the Activiti API. 
    </para>
    
    <section id="bpmnFirstExampleUseCase">
      
      <title>Use case</title>
      
      <para>
				The use case is straightfoward: we have a company, let's call it BPMCorp.
				In BPMCorp, a financial report needs to be written every month for the
				company shareholders. This is the responsibility of the accountancy
				department. When the report is finished, one of the members of the
				upper management needs to approve the document before it is sent to all
				the shareholders.
      </para> 
      
      <para>
        All files and code snippets used through the next sections can be found
        in the <link linkend="examples">examples</link> shipped with the Activiti distribution.
        Look for the package <emphasis>org.activiti.examples.bpmn.usertask</emphasis>.
      </para>   
    
    </section>
    
    <section id="bpmnFirstExampleDiagram">
    
      <title>Process diagram</title>
    
      <para>
				The business process as described above, can be graphically visualized
				using the Activiti Modeler. The end result, in BPMN 2.0 notation, looks
				like this:
			  <mediaobject><imageobject><imagedata align="center" fileref="images/financial.report.example.diagram.png"/></imageobject></mediaobject>
        There is nothing spectacular here. What we see is a <link linkend="bpmnNoneStartEvent">none start event</link> (circle on the left),
        followed by two <link linkend="bpmnUserTask">user tasks</link>:
        <emphasis>'Write monthly financial report'</emphasis> and 
        <emphasis>'Verify monthly financial report'</emphasis>, ending in
        a <link linkend="bpmnNoneEndEvent">none end event</link> (circle with thick border on the right).
      </para>
    
    </section>
    
    <section id="bpmnFirstExampleXml">
    
      <title>XML representation</title>
      
      <para>
        The XML version of this business process (<emphasis>FinancialReportProcess.bpmn20.xml</emphasis>) looks as shown below.
        It's easy to recognize the main elements of our process (click on the links
        for going to the detailed section of that BPMN 2.0 construct):
        <itemizedlist>
          <listitem>
            <para>
              The <link linkend="bpmnNoneStartEvent">(none) start event</link>
              learns us where to start with the process
            </para>
          </listitem>
          <listitem>
            <para>
              The <link linkend="bpmnUserTask">user tasks</link> declarations are the representation
              of the human tasks of our process. Note that the first task is assigned
              to the <emphasis>accountancy</emphasis> group, while the second task is 
              assigned to the <emphasis>management</emphasis> group.
              See <link linkend="bpmnUserTaskAssignment">the section on user task assignment</link>
              for more information on how users and groups can be assigned
              to user tasks.
            </para>
          </listitem>
          <listitem>
            <para>
              The process ends when the <link linkend="bpmnNoneEndEvent">none end event</link>
              is reached.
            </para> 
          </listitem>
        </itemizedlist>
        <programlisting>
&lt;process id=&quot;financialReport&quot; name=&quot;Monthly financial report reminder process&quot;&gt;
  
  &lt;startEvent id=&quot;theStart&quot; /&gt;
    
  &lt;sequenceFlow id='flow1' sourceRef='theStart' targetRef='writeReportTask' /&gt;
    
  &lt;userTask id=&quot;writeReportTask&quot; name=&quot;Write monthly financial report&quot; &gt;
    &lt;documentation&gt;
      Write monthly financial report for publication to shareholders.
    &lt;/documentation&gt;
    &lt;potentialOwner&gt;
      &lt;resourceAssignmentExpression&gt;
        &lt;formalExpression&gt;accountancy&lt;/formalExpression&gt;
      &lt;/resourceAssignmentExpression&gt;
    &lt;/potentialOwner&gt;
  &lt;/userTask&gt;
    
  &lt;sequenceFlow id='flow2' sourceRef='writeReportTask' targetRef='verifyReportTask' /&gt;
      
  &lt;userTask id=&quot;verifyReportTask&quot; name=&quot;Verify monthly financial report&quot; &gt;
    &lt;documentation&gt;
      Verify monthly financial report composed by the accountancy department.
      This financial report is going to be sent to all the company shareholders.  
    &lt;/documentation&gt;
    &lt;potentialOwner&gt;
      &lt;resourceAssignmentExpression&gt;
        &lt;formalExpression&gt;management&lt;/formalExpression&gt;
      &lt;/resourceAssignmentExpression&gt;
    &lt;/potentialOwner&gt;
  &lt;/userTask&gt;
    
  &lt;sequenceFlow id='flow3' sourceRef='verifyReportTask' targetRef='theEnd' /&gt;
      
  &lt;endEvent id=&quot;theEnd&quot; /&gt;
      
&lt;/process&gt;</programlisting>        
      </para>
    
    </section>
    
    <section id="bpmnFirstExamplStartProcess">
    
      <title>Starting a process instance</title>
      
      <para>
        We now have defined the <emphasis role="bold">process definition</emphasis> of our
        business process. From such a process
        definition, we can create at runtime <emphasis role="bold">process instances</emphasis>.
        In this case, one process instance would match with the creation and verification
        of the financial report every month.
      </para>
      
      <para>
        To be able to create process instances from a given process definition,
        we must first <emphasis role="bold">deploy</emphasis> this process definition.
        Deploying a process definition means two things:
        <itemizedlist>
          <listitem>
            <para>
              The process definition will be stored in the persistent datastore that
              is configured for your Activiti engine. So by deploying our business process,
              we make sure that the engine will find the process definition after an engine reboot.
            </para>
          </listitem>
          <listitem>
            <para>
              The BPMN 2.0 process file will be parsed to an in-memory object model
              that can be manipulated through the Activiti API.
            </para>
          </listitem>
        </itemizedlist>
        More information on deployment can be found <link linkend="chDeployment">in the dedicated section on deployment</link>.
      </para>
      
      <para>
        As described <link linkend="chDeployment">in that section</link>, deployment can happen in several
        ways. One way is through the API as follows:
        <programlisting>Deployment deployment = repositoryService.createDeployment()
  .addClasspathResource("org/activiti/examples/bpmn/usertask/FinancialReportProcess.bpmn20.xml")
  .deploy();</programlisting>
      </para>
      
      <para>
        Now we can start a new process instance using 
        the <emphasis>id</emphasis> we defined in the process definition (see first line of the XML).
        Note that this <emphasis>id</emphasis> in Activiti terminology
        is called the <emphasis role="bold">key</emphasis>.
        <programlisting>ProcessInstance processInstance = runtimeService.startProcessInstanceByKey("financialReport");</programlisting>
        This will create a runtime execution that
        will go first through the start event. After the start event, it follows all the outgoing
        sequence flow (only one in this case) and the first task ('write monthly financial report')
        is reached. The Activiti engine will now store a task in the persistent datastore. 
        At this point, the user or group assignments attached to the task are resolved and also stored in the 
        datastore.
      </para>
      
      <para>
        After the task is created, the <emphasis>startProcessInstanceByKey</emphasis> will return
        since the user task activity is a so-called <emphasis>wait state</emphasis>, which
        means that the engine will continue the process instance only when some external trigger is 
        given. In this case, the task is assigned to a group, which means that the every
        member of the group is a <emphasis role="bold">candidate</emphasis> to perform the task.
      </para>
    
    </section>
    
    <section id="bpmnFirstExampleCandidateList">
    
      <title>Task lists</title>  
      
      <para>
        We can now retrieve this newly created task through the <emphasis>taskService</emphasis>.
        <programlisting>List&lt;Task&gt; tasks = taskService.createTaskQuery().taskCandidateUser(&quot;fozzie&quot;).list();</programlisting>
        Note that the user we pass to this operation needs to be a member of 
        the <emphasis>accountancy</emphasis> group, since that was declared in the process definition:
        <programlisting>
&lt;potentialOwner&gt;
  &lt;resourceAssignmentExpression&gt;
    &lt;formalExpression&gt;<emphasis role="bold">accountancy</emphasis>&lt;/formalExpression&gt;
  &lt;/resourceAssignmentExpression&gt;
&lt;/potentialOwner&gt;</programlisting>
     
        We could also use the task query API to get the same results using the name of the group:
         <programlisting>List&lt;Task&gt; tasks = taskService.createTaskQuery().taskCandidateGroup(&quot;accountancy&quot;).list();</programlisting>
      </para>
      
      <para>
        The business process described here is also deployed as an example to the demo setup database.
        After running the <link linkend="demo.setup">demo setup</link>, log into the Activiti Explorer
        as <emphasis role="bold">fozzie</emphasis> (he's an accountant), select the <emphasis>Processes</emphasis> page and
        and click on the <emphasis>'Start Process'</emphasis> link in the <emphasis>'Actions'</emphasis> column corresponding to the <emphasis>'Monthly financial report'</emphasis> process.
        
        <mediaobject><imageobject><imagedata align="center" fileref="images/bpmn.financial.report.example.start.process.png"/></imageobject></mediaobject>
        
        As explained, the process will execute up to the first user task. Since we're logged in
        as fozzie, we can see that there is a new candidate task available for him after we've started
        the process instance. Select the <emphasis>Tasks</emphasis> page to view this new task. 
        Note that even if the process was started by someone else, the task would still
        be visible as a candidate task to everyone in the accountancy group.
        
        <mediaobject><imageobject><imagedata align="center" fileref="images/bpmn.financial.report.example.task.assigned.png"/></imageobject></mediaobject>
        
      </para>
      
    </section>
    
    <section id="bpmnFirstExampleClaimTask">
    
      <title>Claiming the task</title>
      
      <para>
        An accountant now needs to <emphasis role="bold">claim the task</emphasis>. By claiming the
        task, the specific user will become the <emphasis role="bold">assignee</emphasis> of the task
        and the task will disappear from every task list of the other members of the accountancy group.
        Claiming a task is programmatically done as follows:
        <programlisting>taskService.claim(task.getId(), &quot;fozzie&quot;);</programlisting>
        The task is now in the <emphasis role="bold">personal task list of the one
        that claimed the task</emphasis>.
        <programlisting>List&lt;Task&gt; tasks = taskService.createTaskQuery().taskAssignee(&quot;fozzie&quot;);</programlisting>
      </para>
      
      <para>
        In the Activiti Explorer UI, clicking the <emphasis>claim</emphasis> button will
        call the same operation. The task will now move to the personal task list of the logged
        on user.
        
       <mediaobject><imageobject><imagedata align="center" fileref="images/bpmn.financial.report.example.claim.task.png"/></imageobject></mediaobject>
      </para>
      
    </section>
      
    <section id="bpmnFirstExampleCompleteTask">
    
      <title>Completing the task</title>
      
      <para>
        The accountant can now start working on the financial report. Once the report is finished,
        he can <emphasis role="bold">complete the task</emphasis>, which means that all
        work for that task is done.
        <programlisting>taskService.complete(task.getId());</programlisting>
      </para>
      
      <para>
        For the Activiti engine, this is an external signal that the process instance execution
        must be continued. The task itself is removed from the runtime data.
        The single outgoing transition out of the task is followed, bringing
        the execution in the second task (<emphasis>'verification of the report'</emphasis>). 
        The same mechanism as described for the first task will now
        happen, with the small difference that the task will be assigned to the 
        <emphasis>management</emphasis> group.
      </para>
      
      <para>
        In the demo setup, completing the task is done by clicking the <emphasis>complete</emphasis>
        button in the task list. Since Fozzie isn't an accountant, we need to log out of
        the Activiti Explorer and login in as <emphasis>kermit</emphasis> (which is a manager).
        The second task is now visible in the unassigned task lists.
        
        <mediaobject><imageobject><imagedata align="center" fileref="images/bpmn.financial.report.example.complete.task.png"/></imageobject></mediaobject>
      </para>
      
    </section>
      
    <section id="bpmnFirstExampleEndingProcess">

      <title>Ending the process</title>
        
      <para>
        The verification task can be retrieved and claimed in exactly the same way as before.
        Completing this second task, will bring process execution at the end event, which finishes
        the process instance. The process instance and all related runtime execution data
        is removed from the datastore.
      </para>
      
      <para>
        When you log into Activiti Probe you can verify this, since no records will be 
        found in the table where the process executions are stored.
        
         <mediaobject><imageobject><imagedata align="center" fileref="images/bpmn.financial.report.example.process.ended.png"/></imageobject></mediaobject> 
      </para>
      
    </section>
    
    <section id="bpmnFirstExampleFutureEnhancements">
    
      <title>Future enhancements</title>
      
      <para>
        It's easy to see that this business process is too simple to be usable in reality.
        However, as you are going through the BPMN 2.0 constructs available in Activiti, 
        you will be able to enhance the business process by 
        
        <itemizedlist>
          <listitem>
            <para>
              defining a <emphasis role="bold">timer start event</emphasis> that
              automatically starts a process instance at the end of every month.
            </para>
          </listitem>
          <listitem>
            <para>
              defining <emphasis role="bold">gateways</emphasis> that act as decisions.
              This way, a manager could reject the financial report which would recreate
              the task for the accountant. 
            </para>
          </listitem>
          <listitem>
            <para>
              declaring and using <emphasis role="bold">variables</emphasis>,
              such that we can store or reference the report so that it can 
              be visualized in the form.
            </para>
          </listitem>
          <listitem>
            <para>
              defining a <emphasis role="bold">service task</emphasis> at the end of
              the process that will send the report to every shareholder.
            </para>
          </listitem>
          <listitem>
            <para>
              etc.
            </para>
          </listitem>
        </itemizedlist>
      </para>
    
    </section>
  	
	</section>

	<section id="bpmnConstructs">

		<title>BPMN 2.0 constructs</title>
		
			<section id="bpmnCustomExtensions">
	
	    <title>Custom extensions</title>
	
	    <para>
	      The BPMN 2.0 standard is a good thing for all parties involved. End-users don't suffer
	      from a vendor lock-in that comes by depending on a proprietary solution. Frameworks,
	      and particularly open-source frameworks such as Activiti, can implement a solution
	      that has the same (and often better implemented ;-) features as those of a big vendor. 
	      Due to the BPMN 2.0 standard, the transition from such a big vendor solution towards
	      Activiti is an easy and smooth path.  
	    </para>
	    
	    <para>
	      The downside of a standard however, is the fact that it is always the result of 
	      many discussions and compromises between different companies (and often visions). 
	      As a developer reading the BPMN 2.0 XML of a process definition, sometimes it feels like 
	      certain constructs or way to do things are too cumbersome.
	      Since Activiti puts ease of development as a top-priority, we introduced something called the
	      <emphasis role="bold">'Activiti BPMN extensions'</emphasis>.
	      These 'extensions' are new constructs or ways to simplify certain constructs, that
	      are not in the BPMN 2.0 specification.
	    </para>
	    
	    <para>
	      Although the BPMN 2.0 specification clearly states that it was made for custom extension,
	      we make sure that:
	      <itemizedlist>
	        <listitem>
	          <para>
	            The prerequisite of such a custom extension is that there 
	            <emphasis role="bold">always</emphasis> must be a simple transformation to
	            the <emphasis role="bold">standard way of doing things</emphasis>.
	            So when you decide to use a custom extension, you don't have to be afraid 
	            that there is no way back.
	          </para>
	        </listitem>
	        <listitem>
	          <para>
	            When using a custom extension, this is always clearly indicated by giving
	            the new XML element, attribute, etc. the <emphasis role="bold">activiti:</emphasis> 
	            namespace prefix.
	          </para>
	        </listitem>
	        <listitem>
	          <para>
	            The goal of these extensions is to eventually push them back into a next version
	            of the BPMN specification, or at least trigger a discussion that can lead to a revision
	            of that specific BPMN construct. 
	          </para>
	        </listitem>
	      </itemizedlist> 
	    </para>
	    
	    <para>
	      So whether you want to use a custom extension or not, is completely up to you. 
	      Several factors will influence this decision (graphical editor usage, company policy, etc.).
	      We only provide them since we believe that some points in the standard can be done
	      simpler or more efficient. Feel free to give us (positive and/or negative) feedback on 
	      our extensions, or to post new ideas for custom extensions. Who knows, some day your idea
	      might pop up in the specification!.
	    </para>
	  
	  </section>
	  
	  <section id="bpmnEvents">
	   
	    <title>Events</title>
	    
	    <para>
	     Events are used to model something that happens during the lifetime process.
	     Events are always visualized as a circle.
	     
	     In BPMN 2.0, there exist
	     two main event categories: <emphasis>catching</emphasis> or <emphasis>throwing</emphasis> event.
       <itemizedlist>
         <listitem>
           <para>
             <emphasis role="bold">Catching: </emphasis>when process execution arrives in the event,
             it will wait for a trigger to happen. The type of trigger is defined by the inner icon
             or the type declaration in the XML. Catching events are visually differentiated from a 
             throwing event by the inner icon that is not filled (i.e. it is white).
           </para>
         </listitem>
         <listitem>
           <para>
             <emphasis role="bold">Throwing: </emphasis>when process execution arrives in the event, a 
              trigger is fired. The type of trigger is defined by the inner icon or the type declaration
              in the XML. Throwing events are visually differentiated from a catching event by
              the inner icon that is filled with black.
           </para>
         </listitem>
       </itemizedlist>
	     
	    </para>
	   
	  </section>
	  
	  <section id="bpmnStartEvents">
	  
	   <title>Start events</title>
	  
	   <para>
	     A start event indicates where a process starts. The type of start event (process starts on arrival of 
	     message, on specific time intervals, etc.), defining <emphasis>how</emphasis> the process is
	     started is shown as a small icon in the visual representation of the event. In the XML representation,
	     the type is given by the declaration of a sub-element.
	   </para>
	   
	   <para>
	     Start events <emphasis role="bold">are always catching</emphasis>: conceptually
	     the event is (at any time) waiting until a certain trigger happens.
	   </para>
	   
	   <para>
	     In a start event, following activiti-specific properties can be specified:
	   </para>
	   
	   <itemizedlist>
       <listitem>
         <para>
           <emphasis role="bold">formKey</emphasis>: references to a form template that users have to fill in
           when starting a new process instance.  More information can be found in 
           <link linkend="forms">the forms section</link> Example:
           <programlisting>&lt;startEvent id=&quot;request&quot; activiti:formKey=&quot;org/activiti/examples/taskforms/request.form&quot; /&gt;</programlisting>
         </para>
       </listitem>
       <listitem>
         <para>
           <emphasis role="bold">initiator</emphasis>: identifies the variable name in which the authenticated 
           user id will be stored when the process is started.  Example:
           <programlisting>&lt;startEvent id=&quot;request&quot; activiti:initiator=&quot;initiator&quot; /&gt;</programlisting>
           The authenticated user must be set with the method <literal>IdentityService.setAuthenticatedUserId(String)</literal>
           in a try-finally block like this:
           <programlisting>try {
  identityService.setAuthenticatedUserId(&quot;bono&quot;);
  runtimeService.startProcessInstanceByKey(&quot;someProcessKey&quot;);
} finally {
  identityService.setAuthenticatedUserId(null);
}
</programlisting>
           This code is baked into the Activiti Explorer application.  So it works in combination with 
           <xref linkend="forms" />
         </para>
       </listitem>
     </itemizedlist>
	   
	  
	  </section>

		<section id="bpmnNoneStartEvent">

			<title>None start event</title>
			
			<section id="noneStartEventDescription">
       
        <title>Description</title>
        
        <para>
          A 'none' start event technically means that the trigger for starting the process instance
          is unspecified. This means that the engine cannot anticipate when the process instance must
          be started. The none start event is used when the process instance is started through the API
          by calling one of the <emphasis>startProcessInstanceByXXX</emphasis> methods.
          <programlisting>
ProcessInstance processInstance = runtimeService.startProcessInstanceByXXX();</programlisting>
        </para>
        
        <para>
          <emphasis>Note: </emphasis> a subprocess always has a none start event.
        </para>
       
      </section>

			<section id="noneStartEventGraphicalNotation">
			 
			  <title>Graphical notation</title>
			  
			  <para>
			    A none start event is visualized as a circle with no inner icon (i.e. no trigger type). 
			    <mediaobject><imageobject><imagedata align="center" fileref="images/bpmn.none.start.event.png"/></imageobject></mediaobject>
			  </para>
			 
			</section>
			
			<section id="noneStartEventXml">
       
        <title>XML representation</title>
        
        <para>
          The XML representation of a none start event is the normal
          start event declaration, without any sub-element (other start event types
          all have a sub-element declaring the type).
          <programlisting>
&lt;startEvent id=&quot;start&quot; name=&quot;my start event&quot; /&gt;</programlisting>
        </para>
       
      </section>

		</section>
		
		<section id="bpmnEndEvent">
		
		  <title>End events</title>
		  
		  <para>
		    An end event signifies the end (of a path) of a (sub)process. An end event is 
		    <emphasis role="bold">always throwing</emphasis>. This means that when process execution
		    arrives in the end event, a <emphasis>result</emphasis> is thrown. The type of result 
		    is depicted by the inner black icon of the event. In the XML representation,
		    the type is given by the declaration of a sub-element.
		  </para>
		
		</section>

		<section id="bpmnNoneEndEvent">
		
		  <title>None end event</title>

      <section id="noneEndEventDescription">

			 <title>Description</title>
        
        <para>
          A 'none' end event means that the <emphasis>result</emphasis> thrown when
          the event is reached is unspecified. As such, the engine will not do anything
          extra besides ending the current path of execution.
        </para>
       
      </section>

      <section id="bpmnNoneEndEventDescription">
       
        <title>Graphical notation</title>
        
        <para>
          A none end event is visualized as a circle with a thick border with no inner icon (no result type).
          <mediaobject><imageobject><imagedata align="center" fileref="images/bpmn.none.end.event.png"/></imageobject></mediaobject>
        </para>
       
      </section>
      
      <section id="bpmnNoneStartEventXml">
       
        <title>XML representation</title>
        
        <para>
          The XML representation of a none end event is the normal
          end event declaration, without any sub-element (other end event types
          all have a sub-element declaring the type).
          <programlisting>
&lt;endEvent id=&quot;end&quot; name=&quot;my end event&quot; /&gt;</programlisting>
        </para>
       
      </section>

		</section>
		
	  <section id="bpmnSequenceFlow">
    
      <title>Sequence flow</title>
      
      <section id="sequenceFlowDescription">
      
        <title>Description</title>
        
        <para>
          A sequence flow is the connector between two elements of a process.
          After an element is visited during process execution, all outgoing sequence flow
          will be followed. This means that the default nature of BPMN 2.0 is to be parallel:
          two outgoing sequence flow will create two separate, parallel paths of execution.
        </para>
      
      </section>
      
      <section id="sequenceFlowGraphicalNotation">
      
        <title>Graphical notation</title>
        
        <para>
          A sequence flow is visualized as an arrow going from the source element towards
          the target element. The arrow always points towards the target.
          <mediaobject><imageobject><imagedata align="center" fileref="images/bpmn.sequence.flow.png"/></imageobject></mediaobject>
        </para>
      
      </section>
      
      <section id="sequenceFlowXml">
      
        <title>XML representation</title>
        
        <para>
          Sequence flow need to have a process-unique <emphasis role="bold">id</emphasis>,
          and a reference to an existing <emphasis role="bold">source</emphasis>
          and <emphasis role="bold">target</emphasis> element.
          <programlisting>
&lt;sequenceFlow id=&quot;flow1&quot; sourceRef=&quot;theStart&quot; targetRef=&quot;theTask&quot; /&gt;</programlisting>
        </para>
      
      </section>
    
    </section>
    
    <section id="bpmnConditionalSequenceFlow">
    
      <title>Conditional sequence flow</title>
      
      <section id="condSeqFlowDescription">
      
        <title>Description</title>
        
        <para>
          A sequence flow can have a condition defined on it. When a BPMN 2.0 activity
          is left, the default behavior is to evaluate the conditions on the outgoing
          sequence flow. When a condition evaluates to <emphasis>true</emphasis>, that
          outgoing sequence flow is selected. When multiple sequence flow are selected
          that way, multiple <emphasis>executions</emphasis> will be generated
          and the process will be continued in a parallel way.
        </para>
        
        <para>
          <emphasis role="bold">Note:</emphasis> the above holds for BPMN 2.0 activities (and events),
          but not for gateways. Gateways will handle sequence flow with conditions in specific ways,
          depending on the gateway type.
        </para>
      
      </section>
      
      <section id="conditionalSequenceFlowGraphicalNotation">
      
        <title>Graphical notation</title>
        
        <para>
          A conditional sequence flow is visualized as a regular sequence flow,
          with a small diamond at the beginning. The condition expression is shown
          next to the sequence flow.
          <mediaobject><imageobject><imagedata align="center" fileref="images/bpmn.conditional.sequence.flow.png"/></imageobject></mediaobject>
        </para>
      
      </section>
      
      <section id="conditionalSequenceFlowXml">
      
        <title>XML representation</title>
        
        <para>
          A conditional sequence flow is represented in XML as a regular sequence flow,
          containing a <emphasis role="bold">conditionExpression</emphasis> sub-element.
          Note that for the moment only <emphasis>tFormalExpressions</emphasis> are supported,
          Omitting the <emphasis>xsi:type=&quot;&quot;</emphasis> definition will simply
          default to this only supported type of expressions. 
          <programlisting>&lt;sequenceFlow id=&quot;flow&quot; sourceRef=&quot;theStart&quot; targetRef=&quot;theTask&quot;&gt;
  &lt;conditionExpression xsi:type=&quot;tFormalExpression&quot;&gt;
    &lt;![CDATA[${order.price &gt; 100 &amp;&amp; order.price &lt; 250}]]&gt;
  &lt;/conditionExpression&gt;
&lt;/sequenceFlow&gt;</programlisting>
        </para>
        <para> 
          Currently conditionalExpressions can <emphasis role="bold">only be used with UEL</emphasis>, detailed info about these can be found in section <link linkend="apiExpressions">Expressions</link>.
          The expression used should resolve to a boolean value, otherwise an exception is thrown while evaluating the condition.  
          <itemizedlist>
            <listitem>
              <para>
                The example below references data of a process 
                variable, in the typical JavaBean style through getters. 
              </para>
              <para>
<programlisting>&lt;conditionExpression xsi:type=&quot;tFormalExpression&quot;&gt;
  &lt;![CDATA[${order.price &gt; 100 &amp;&amp; order.price &lt; 250}]]&gt;
&lt;/conditionExpression&gt;</programlisting>
              </para>
            </listitem>
             <listitem>
              <para>
                This example invokes a method that resolves to a boolean value.
<programlisting>&lt;conditionExpression xsi:type=&quot;tFormalExpression&quot;&gt;
  &lt;![CDATA[${order.isStandardOrder()}]]&gt;
&lt;/conditionExpression&gt;</programlisting>                
              </para>
            </listitem>
          </itemizedlist>
          
        </para>
        
        <para>
          The Activiti distribution contains the following example process using value and method expressions
          (see <emphasis>org.activiti.examples.bpmn.expression)</emphasis>:
          <mediaobject><imageobject><imagedata align="center" fileref="images/bpmn.uel-expression.on.seq.flow.png"/></imageobject></mediaobject>
        </para>
      
      </section>
      
    </section>
    
    <section id="bpmnGateways">
    
      <title>Gateways</title>
      
      <para>
        A gateway is used to control the flow of execution (or as the BPMN 2.0 describes,
        the <emphasis>tokens</emphasis> of execution). A gateway is capable of <emphasis>consuming</emphasis>
        or <emphasis>generating</emphasis> tokens.
      </para>
        
      <para>  
        A gateway is graphically visualized as a diamond shape, with an icon inside. 
        The icon shows the type of gateway.
         <mediaobject><imageobject><imagedata align="center" fileref="images/bpmn.gateway.png"/></imageobject></mediaobject>
      </para>
    
    </section>
    
    <section id="bpmnExclusiveGateway">
    
      <title>Exclusive gateway</title>
      
      <section id="exclusiveGatewayDescription">
      
        <title>Description</title>
        
        <para>
          An exclusive gateway (also called the <emphasis>XOR gateway</emphasis> 
          or more technical the <emphasis>exclusive data-based gateway</emphasis>),
          is used to model a <emphasis role="bold">decision</emphasis> in the process.
          When the execution arrives at this gateway, all outgoing sequence flow are
          evaluated in the order in which they are defined. The sequence flow
          which condition evaluates to true (or which doesn't have a condition set, 
          conceptually having a <emphasis>'true'</emphasis> defined on the sequence flow)
          is selected for continuing the process. 
        </para>
        
        <para>
          <emphasis role="bold">Note that the semantics of outgoing sequence flow is 
          different to that of the general case in BPMN 2.0. While in general all sequence
          flow which condition evaluates to true are selected to continue in a parallel way,
          only one sequence flow is selected when using the exclusive gateway. 
          In case multiple sequence flow have a condition that evaluates to true, the 
          first one defined in the XML (and only that one!) is selected for continuing the process.
          If no sequence flow can be selected, an exception will be thrown.</emphasis>
        </para>
        
      </section>
      
      <section id="exclusiveGatewayGraphNotation">
      
        <title>Graphical notation</title>
        
        <para>
          An exclusive gateway is visualized as a typical gateway (i.e. a diamond shape)
          with an 'X' icon inside, referring to the <emphasis>XOR</emphasis> semantics.
          Note that a gateway without an icon inside defaults to an exclusive gateway.
          The BPMN 2.0 specification does not allow mixing the diamond with and without an X
          in the same process definition.
          <mediaobject><imageobject><imagedata align="center" fileref="images/bpmn.exclusive.gateway.notation.png"/></imageobject></mediaobject>
        </para>
      
      </section>
      
      <section id="exclusiveGatewayXML">
      
        <title>XML representation</title>
        
        <para>
          The XML representation of an exclusive gateway is straight-forward: one line defining
          the gateway and condition expressions defined on the outgoing sequence flow. 
          See the section on <link linkend="bpmnConditionalSequenceFlow">conditional sequence flow</link>
          to see which options are available for such expressions.
       </para>
       
       <para>   
          Take for example the following model:
          <mediaobject><imageobject><imagedata align="center" fileref="images/bpmn.exclusive.gateway.png"/></imageobject></mediaobject> 
          Which is represented in XML as follows:
          <programlisting>&lt;exclusiveGateway id=&quot;exclusiveGw&quot; name=&quot;Exclusive Gateway&quot; /&gt;
    
&lt;sequenceFlow id=&quot;flow2&quot; sourceRef=&quot;exclusiveGw&quot; targetRef=&quot;theTask1&quot;&gt;
  &lt;conditionExpression xsi:type=&quot;tFormalExpression&quot;&gt;${input == 1}&lt;/conditionExpression&gt;
&lt;/sequenceFlow&gt;
    
&lt;sequenceFlow id=&quot;flow3&quot; sourceRef=&quot;exclusiveGw&quot; targetRef=&quot;theTask2&quot;&gt;
  &lt;conditionExpression xsi:type=&quot;tFormalExpression&quot;&gt;${input == 2}&lt;/conditionExpression&gt;
&lt;/sequenceFlow&gt;
    
&lt;sequenceFlow id=&quot;flow4&quot; sourceRef=&quot;exclusiveGw&quot; targetRef=&quot;theTask3&quot;&gt;
  &lt;conditionExpression xsi:type=&quot;tFormalExpression&quot;&gt;${input == 3}&lt;/conditionExpression&gt;
&lt;/sequenceFlow&gt;</programlisting>
        </para>
        
      </section>
    
    </section>
    
    <section id="bpmnParallelGateway">
      
      <title>Parallel Gateway</title>
      
      <section id="bpmnParallelGatewayDescription">
        
        <title>Description</title>
        
        <para>
          Gateways can also be used to model concurrency in a process. The most straightforward
          gateway to introduce concurrency in a process model, is the 
          <emphasis role="bold">Parallel Gateway</emphasis>, which allows to <emphasis>fork</emphasis> 
          into multiple paths of execution or <emphasis>join</emphasis> multiple incoming paths
          of execution.
        </para>
        
        <para>
          The functionality of the parallel gateway is based on the incoming and outgoing sequence flow:
          <itemizedlist>
            <listitem>
              <para>
                <emphasis role="bold">fork:</emphasis>
                all outgoing sequence flow are followed in parallel, creating one concurrent
                execution for each sequence flow.
              </para>
            </listitem>
            <listitem>
              <para>
                <emphasis role="bold">join:</emphasis>   
                all concurrent executions arriving at the parallel gateway wait in the gateway
                until an execution has arrived for each of the incoming sequence flow. Then the 
                process continues past the joining gateway.
              </para>
            </listitem>
          </itemizedlist>
          Note that a parallel gateway can have <emphasis role="bold">both fork and join behavior</emphasis>,
          if there are multiple incoming and outgoing sequence flow for the same parallel gateway.
          In that case, the gateway will first join all incoming sequence flow, before splitting
          into multiple concurrent paths of executions.
        </para>
        
        <para>
          <emphasis role="bold">An important difference with other gateway types is that
          the parallel gateway does not evaluate conditions. If conditions are defined
          on the sequence flow connected with the parallel gateway, they are simply neglected.</emphasis>  
        </para>
      
      </section>
      
      <section id="bpmnParallelGatewayGraphicalNotation">
        
        <title>Graphical Notation</title>
        
        <para>
          A parallel gateway is visualized as a gateway (diamond shape) with the 'plus' symbol inside,
          referring to the 'AND' semantics.
          <mediaobject><imageobject><imagedata align="center" fileref="images/bpmn.parallel.gateway.png"/></imageobject></mediaobject>
        </para>
      
      </section>
      
      <section id="bpmnParallelGatewayyXML">
        
        <title>XML representation</title>
        
        <para>
          Defining a parallel gateway needs one line of XML:
          <programlisting>&lt;parallelGateway id=&quot;myParallelGateway&quot; /></programlisting>
          The actual behavior (fork, join or both), is defined by 
          the sequence flow connected to the parallel gateway.
        </para>
      
        <para>
          For example, the model above comes down to the following XML:
<programlisting>
    &lt;startEvent id=&quot;theStart&quot; /&gt;
    &lt;sequenceFlow id=&quot;flow1&quot; sourceRef=&quot;theStart&quot; targetRef=&quot;fork&quot; /&gt;
    
    <emphasis role="bold">&lt;parallelGateway id=&quot;fork&quot; /&gt;</emphasis>
    &lt;sequenceFlow sourceRef=&quot;fork&quot; targetRef=&quot;receivePayment&quot; /&gt;
    &lt;sequenceFlow sourceRef=&quot;fork&quot; targetRef=&quot;shipOrder&quot; /&gt;
    
    &lt;userTask id=&quot;receivePayment&quot; name=&quot;Receive Payment&quot; /&gt;  
    &lt;sequenceFlow sourceRef=&quot;receivePayment&quot; targetRef=&quot;join&quot; /&gt;
    
    &lt;userTask id=&quot;shipOrder&quot; name=&quot;Ship Order&quot; /&gt; 
    &lt;sequenceFlow sourceRef=&quot;shipOrder&quot; targetRef=&quot;join&quot; /&gt;
    
    <emphasis role="bold">&lt;parallelGateway id=&quot;join&quot; /&gt;</emphasis>
    &lt;sequenceFlow sourceRef=&quot;join&quot; targetRef=&quot;archiveOrder&quot; /&gt;
    
    &lt;userTask id=&quot;archiveOrder&quot; name=&quot;Archive Order&quot; /&gt; 
    &lt;sequenceFlow sourceRef=&quot;archiveOrder&quot; targetRef=&quot;theEnd&quot; /&gt;
    
    &lt;endEvent id=&quot;theEnd&quot; /&gt;
</programlisting>
        </para>
        
        <para>
          In the above example, after the process is started, two tasks will be created:
          <programlisting>ProcessInstance pi = runtimeService.startProcessInstanceByKey("forkJoin");
TaskQuery query = taskService.createTaskQuery()
                         .processInstanceId(pi.getId())
                         .orderByTaskName()
                         .asc();

List&lt;Task&gt; tasks = query.list();
assertEquals(2, tasks.size());

Task task1 = tasks.get(0);
assertEquals("Receive Payment", task1.getName());
Task task2 = tasks.get(1);
assertEquals("Ship Order", task2.getName());</programlisting>
          When these two tasks are completed, the second parallel gateway will join the two
          executions and since there is only one outgoing sequence flow, no concurrent paths
          of execution will be created, and only the <emphasis>Archive Order</emphasis>
          task will be active.
        </para>
        
        <para>
          Note that a parallel gateway does not need to be 'balanced' (i.e. a matching number
          of incoming/outgoing sequence flow for corresponding parallel gateways). 
          A parallel gateway will simply wait for all incoming sequence flow and create 
          a concurrent path of execution for each outgoing sequence flow, not influenced by
          other constructs in the process model. So, the following process is legal in BPMN 2.0:
          <mediaobject><imageobject><imagedata align="center" fileref="images/bpmn.unbalanced.parallel.gateway.png"/></imageobject></mediaobject>
        </para>
      
      </section>
   
    </section> 

		<section id="bpmnUserTask">

			<title>User task</title>

			<section id="bpmnUserTaskDescription">
			
			 <title>Description</title>
			 
			 <para>
			   A 'user task' is used to model work that needs to be done by a human actor. 
			   When the process execution arrives at such a user task, a new task is created in the 
			   task list of the user(s) or group(s) assigned to that task.
			 </para>
			
			</section>
			
			<section id="bpmnUserTaskGraphicalNotation">
			
			 <title>Graphical notation</title>
			 
			 <para>
			   A user task is visualized as a typical task (rounded rectangle), with a small
			   user icon in the left upper corner.
			   <mediaobject><imageobject><imagedata align="center" fileref="images/bpmn.user.task.png"/></imageobject></mediaobject>
			 </para>
			
			</section>
			
			<section id="bpmnUserTaskXml">
			
				<title>XML representation</title>
				
				<para>
				  A user task is defined in XML as follows. The <emphasis>id</emphasis> attribute
				  is required, the <emphasis>name</emphasis> attribute is optional.
				  <programlisting>
&lt;userTask id=&quot;theTask&quot; name=&quot;Important task&quot; /&gt;			  
				  </programlisting>
				</para>
				
				<para>
			    A user task can have also a description. In fact any BPMN 2.0 element can have
				  a description. A description is defined by adding
				  the <emphasis role="bold">documentation</emphasis> element.
				  <programlisting>
&lt;userTask id=&quot;theTask&quot; name=&quot;Schedule meeting&quot; &gt;
  &lt;documentation&gt;
	  Schedule an engineering meeting for next week with the new hire.
	&lt;/documentation&gt;</programlisting>
				
				  The description text can be retrieved from the task in the standard Java way:
				  <programlisting>task.getDescription()</programlisting>
				</para>
			
			</section>

			<section id="bpmnUserTaskAssignment">

				<title>User assignment</title>

				<para>
				  A user task can be directly assigned to a user. This is done by defining a
				  <emphasis role="bold">humanPerformer</emphasis> sub element.
				  Such a <emphasis>humanPerformer</emphasis> definition needs a 
				  <emphasis role="bold">resourceAssignmentExpression</emphasis> that actually defines
				  the user. Currently, only <emphasis role="bold">formalExpressions</emphasis> are supported.
				  <programlisting>
&lt;process ... &gt;
  
  ...
  
  &lt;userTask id='theTask' name='important task' &gt;
    &lt;humanPerformer&gt;
      &lt;resourceAssignmentExpression&gt;
        &lt;formalExpression&gt;kermit&lt;/formalExpression&gt;
      &lt;/resourceAssignmentExpression&gt;
    &lt;/humanPerformer&gt;
  &lt;/userTask&gt;</programlisting>
				</para>
				
				<para>
				  <emphasis role="bold">Only one</emphasis> user can be assigned as human performer to the task.
				  In Activiti terminology, this user is called the <emphasis role="bold">assignee</emphasis>.
				  Task that have an assignee are not visible in the task lists of other people, and
				  are found in the so-called <emphasis role="bold">personal task list</emphasis> of the assignee. 
				</para>
				
				<para>
				  Tasks directly assigned to users can be retrieved through the TaskService as follows:
				  <programlisting>List&lt;Task&gt; tasks = taskService.createTaskQuery().taskAssignee(&quot;kermit&quot;).list();</programlisting>
				</para>

        <para>
          Tasks can also be put in the so-called <emphasis role="bold">candidate task list</emphasis>
          of people. In that case, the <emphasis role="bold">potentialOwner</emphasis> construct must be used.
          The usage is similar to the <emphasis>humanPerformer</emphasis> construct. Do note that it is 
          required to define for each element in the formal expression to specify if it is
          a user or a group (the engine cannot guess this).
          <programlisting>
&lt;process ... &gt;
  
  ...
  
  &lt;userTask id='theTask' name='important task' &gt;
    &lt;potentialOwner&gt;
      &lt;resourceAssignmentExpression&gt;
        <emphasis role="bold">&lt;formalExpression&gt;user(kermit), group(management)&lt;/formalExpression&gt;</emphasis>
      &lt;/resourceAssignmentExpression&gt;
    &lt;/potentialOwner&gt;
  &lt;/userTask&gt;</programlisting>
        </para>
        
        <para>
          Tasks defines with the <emphasis>potential owner</emphasis> construct, can be retrieved as follows
          (or a similar <emphasis>TaskQuery</emphasis> usage as for the tasks with an assignee):
          <programlisting>
 List&lt;Task&gt; tasks = taskService.createTaskQuery().taskCandidateUser(&quot;kermit&quot;);</programlisting>
          
          This will retrieve all tasks where kermit is a <emphasis role="bold">candidate user</emphasis>,
          i.e. the formal expression contains <emphasis>user(kermit)</emphasis>. This will also
          retrieve all tasks that are <emphasis role="bold">assigned to a group where kermit is
          a member of</emphasis> (e.g. <emphasis>group(management)</emphasis>, if kermit is a member of that group
          and the Activiti identity component is used).
          The groups of the user are resolved at runtime and these can be 
          managed through the <emphasis>IdentityService</emphasis>.
        </para>
        
        <para>
          If no specifics are given whether the given text string is a user or group, 
          the engine defaults to group. So the following would be the same as when
          <emphasis>group(accountancy) was declared</emphasis>.
          <programlisting>
&lt;formalExpression&gt;accountancy&lt;/formalExpression&gt;</programlisting>
        </para>
        
			</section> <!-- task assignment -->
			
			<section id="bpmnUserTaskUserAssignmentExtension">
          
          <title>Activiti extensions for task assignment</title>
          
          <para>
            It is clear that user and group assignments are quite cumbersome
            for use cases where the assignment is not complex. 
            To avoid these complexities, <link linkend="bpmnCustomExtensions">custom extensions</link>
            on the user task are possible.
          </para>
          
          <para>
            <itemizedlist>
              <listitem>
                <para>
                  <emphasis role="bold">assignee attribute</emphasis>: this custom extension allows to
                  directly assign a user task to a given user.
                  <programlisting>
&lt;userTask id=&quot;theTask&quot; name=&quot;my task&quot; activiti:assignee=&quot;kermit&quot; /&gt;</programlisting>

                  This is exactly the same as using a <emphasis role="bold">humanPerformer</emphasis> 
                  construct as defined <link linkend="bpmnUserTaskAssignment">above</link>.
                </para>
              </listitem>
              <listitem>
                <para>
                  <emphasis role="bold">candidateUsers attribute</emphasis>: this custom extension allows to
                  make a user a candidate for a task.
                  <programlisting>
&lt;userTask id=&quot;theTask&quot; name=&quot;my task&quot; activiti:candidateUsers=&quot;kermit, gonzo&quot; /&gt;</programlisting>

                  This is exactly the same as using a <emphasis role="bold">potentialOwner</emphasis> 
                  construct as defined <link linkend="bpmnUserTaskAssignment">above</link>.
                  Note that it is not required to use the <emphasis>user(kermit)</emphasis> declaration
                  as is the case with the <emphasis>potential owner</emphasis> construct, since the attribute 
                  can only be used for users.
                </para>
              </listitem>
              <listitem>
                <para>
                  <emphasis role="bold">candidateGroups attribute</emphasis>: this custom extension allows to
                  make a group a candidate for a task.
                  <programlisting>
&lt;userTask id=&quot;theTask&quot; name=&quot;my task&quot; activiti:candidateGroups=&quot;management, accountancy&quot; /&gt;</programlisting>

                  This is exactly the same as using a <emphasis role="bold">potentialOwner</emphasis> 
                  construct as defined <link linkend="bpmnUserTaskAssignment">above</link>.
                  Note that it is not required to use the <emphasis>group(management)</emphasis> declaration
                  as is the case with the <emphasis>potential owner</emphasis> construct, since the attribute 
                  can only be used for groups.
                </para>
              </listitem>
              <listitem>
                <para>
                  <emphasis>candidateUsers</emphasis> and <emphasis>candidateGroups</emphasis> can both
                  be defined on the same user task.
                </para>
              </listitem>
            </itemizedlist>
          </para>
          
          <para>
            In case the previous approaches are not sufficient, it is possible to delegate to 
            custom assignment logic using a <link linkend="taskListeners">task listener</link>
            on the create event:
            <programlisting>
&lt;userTask id=&quot;task1&quot; name=&quot;My task&quot; &gt;
  &lt;extensionElements&gt;
    &lt;activiti:taskListener event=&quot;create&quot; class=&quot;org.activiti.MyAssignmentHandler&quot; /&gt;
  &lt;/extensionElements&gt;
&lt;/userTask&gt;</programlisting>
            The <literal>DelegateTask</literal> that is passed to the <literal>TaskListener</literal>
            implementation, allows to set the assignee and candidate-users/groups:
            <programlisting>
public class MyAssignmentHandler implements TaskListener {

  public void notify(DelegateTask delegateTask) {
    // Execute custom identity lookups here
    
    // and then for example call following methods:
    delegateTask.setAssignee(&quot;kermit&quot;);
    delegateTask.addCandidateUser(&quot;fozzie&quot;);
    delegateTask.addCandidateGroup(&quot;management&quot;);
    ...
  }
  
}</programlisting>
          </para>
          
          <para>
            When using Spring it is possible to use the custom assignment attirbutes as described in the section above,
            and delegate to a Spring bean using a <link linkend="taskListeners">task listener</link>
            with an <link linkend="springExpressions">expression</link> that listens to task <emphasis>create</emphasis> events.
            In the following example, the assignee will be set by calling the <literal>findManagerOfEmployee</literal>
            on the <literal>ldapService</literal> Spring bean. The <emphasis>emp</emphasis> parameter
            that is passed, is a process variable>.
            <programlisting>&lt;userTask id=&quot;task&quot; name=&quot;My Task&quot; activiti:assignee=&quot;${ldapService.findManagerForEmployee(emp)}&quot;/&gt;</programlisting>
            This also works similar for candidate users and groups:
            <programlisting>&lt;userTask id=&quot;task&quot; name=&quot;My Task&quot; activiti:candidateUsers=&quot;${ldapService.findAllSales()}&quot;/&gt;</programlisting>
            Note that this will only work if the return type of the invoked methods is <literal>String</literal>
            or <literal>Collection&lt;String&gt;</literal> (for candidate users and groups):
            <programlisting>            
public class FakeLdapService {
  
  public String findManagerForEmployee(String employee) {
    return &quot;Kermit The Frog&quot;;
  }
  
  public List&lt;String&gt; findAllSales() {
    return Arrays.asList(&quot;kermit&quot;, &quot;gonzo&quot;, &quot;fozzie&quot;);
  }

}</programlisting>
          </para>
          
        </section> <!-- task assignment extensions -->

		</section>
		
		<section id="bpmnScriptTask">
		
		  <title>Script Task</title>
		  
		  <section id="bpmnScriptTaskDescription">
		  
		    <title>Description</title>
		    
		    <para>
		      A script task is an automatic activity. When a process execution arrives at the 
		      script task, the corresponding script is executed. 
		    </para>
		  
		  </section>
		  
		  <section id="bpmnScriptTaskGraphicalNotation">
		  
		    <title>Graphical Notation</title>
		    
		    <para>
		      A script task is visualized as a typical BPMN 2.0 task (rounded rectangle),
		      with a small 'script' icon in the top-left corner of the rectangle.
		      <mediaobject><imageobject><imagedata align="center" fileref="images/bpmn.scripttask.png"/></imageobject></mediaobject>
		    </para>
		  
		  </section>
		  
		  <section id="bpmnScriptTaskXml">
		  
		    <title>XML representation</title>
		    
		    <para>
		      A script task is defined by specifying the <emphasis role="bold">script</emphasis>
		      and the <emphasis role="bold">scriptFormat</emphasis>.
<programlisting>
&lt;scriptTask id=&quot;theScriptTask&quot; name=&quot;Execute script&quot; scriptFormat=&quot;groovy&quot;&gt;
  &lt;script&gt;
    sum = 0
    for ( i in inputArray ) {
      sum += i
    }
  &lt;/script&gt;
&lt;/scriptTask&gt;</programlisting>
		    </para>
		    
		    <para>
		      The value of the <emphasis role="bold">scriptFormat</emphasis> attribute must be a
		      name that is compatible with the <ulink url="http://jcp.org/en/jsr/detail?id=223">JSR-223</ulink>
		      (scripting for the Java platform). The Groovy jar is shipped by default with the
		      Activiti distribution. If you want to use another (JSR-223 compatible) scripting
		      engine, it is sufficient to add the corresponding jar to the classpath and use
		      the appropriate name.
		    </para>
		    
		  </section>
		  
		  <section id="bpmnScriptTaskVariables">
		  
		    <title>Variables in scripts</title>
		    
		    <para>
		      All process variables that are accessible through the execution that arrives in the
		      script task, can be used within the script. In the example, the script variable
		      <emphasis>'inputArray'</emphasis> is in fact a process variable (an array of integers).
<programlisting>
&lt;script&gt;
    sum = 0
    for ( i in <emphasis role="bold">inputArray</emphasis> ) {
      sum += i
    }
&lt;/script&gt;</programlisting>
		    </para>
		    
		    <para>
		      It's also possible to set process variables in a script, simply by using an assignment
		      statement. In the example above, the <emphasis>'sum'</emphasis> variable will be
		      stored as a process variable after the script task has been executed. To avoid 
		      this behavior, script-local variables can be used. In Groovy, the keyword 
		      <emphasis>'def'</emphasis> must then be used: <emphasis>'def sum = 0'</emphasis>.
		      In that case, no process variable will be stored.
		    </para>
		    
		    <para>
		      An alternative is to set variables through the current execution, which is available
		      as a reserved variable called <emphasis>'execution'</emphasis>.
<programlisting>
&lt;script&gt;
    def scriptVar = &quot;test123&quot;
    execution.setVariable(&quot;myVar&quot;, scriptVar)
&lt;/script&gt;</programlisting>
		    </para>
		    
		    <para>
		      Note: the following names are reserved and <emphasis role="bold">cannot be used</emphasis> 
		      as variable names: <emphasis role="bold">out, out:print, lang:import, context, elcontext</emphasis>.
		    </para>
		  
		  </section>

		  <section id="bpmnScriptTaskResultValue">

		    <title>Script results</title>

		    <para>
		      The return value of a script task can be assigned to an already existing or to a new process variable by
              specifying the process variable name as a literal value for the <emphasis>'activiti:resultVariableName'</emphasis> attribute
              of a script task definition. Any existing value for a specific process variable will be overwritten by the result
              value of the script execution. When not specifying a result variable name, the script result value gets ignored.
<programlisting>
&lt;scriptTask id=&quot;theScriptTask&quot; name=&quot;Execute script&quot; scriptFormat=&quot;juel&quot; activiti:resultVariableName=&quot;myVar&quot;&gt;
  &lt;script&gt;#{echo}&lt;/script&gt;
&lt;/scriptTask&gt;</programlisting>

              In the above example, the result of the script execution (the value of the resolved expression <emphasis>'#{echo}'</emphasis>) is set
              to the process variable named <emphasis>'myVar'</emphasis> after the script completes.
		    </para>
		
		  </section>

		</section> 
		
		<section id="bpmnJavaServiceTask">
	
	   <title>Java Service Task</title>
	   
	   <section id="bpmnJavaServiceTaskDescription">
	   
	     <title>Description</title>
	     
	     <para>
	       A Java service task is used to invoke an external Java class.
	     </para>
	   
	   </section>	
	   
	   <section id="bpmnJavaServiceTaskGraphicalNotation">
     
       <title>Graphical Notation</title>
       
       <para>
        A service task is visualized as a rounded rectangle with a small gear icon in the top-left corner.
        <mediaobject><imageobject><imagedata align="center" fileref="images/bpmn.java.service.task.png"/></imageobject></mediaobject>
       </para>
     
     </section> 
     
     <section id="bpmnJavaServiceTaskXML">
     
       <title>XML representation</title>
       
       <para>
         There are 4 ways of declaring how to invoke Java logic:
       </para>
       
       <itemizedlist>
         <listitem><para>Specifying a class that implements JavaDelegate or ActivityBehavior</para></listitem>
         <listitem><para>Evaluating an expression that resolves to a delegation object</para></listitem>
         <listitem><para>Invoking a method expression</para></listitem>
         <listitem><para>Evaluating a value expression</para></listitem>
       </itemizedlist>
       
       <para>
         To specify a class that is called during process execution, the fully qualified classname 
         needs to be provided by the <emphasis role="bold">'activiti:class'</emphasis>
         attribute.
<programlisting>
&lt;serviceTask id=&quot;javaService&quot; 
             name=&quot;My Java Service Task&quot; 
             activiti:class=&quot;org.activiti.MyJavaDelegate&quot; /&gt;
</programlisting>
         See <link linkend="bpmnJavaServiceTaskImplementation">the <emphasis>implementation</emphasis> section</link>
         for more details on how to use such a class.
       </para>
       
       <para>
         It is also possible to use an expression that resolves to an object. This object must follow
         the same rules as objects that are created when the <literal>activiti:class</literal>
         attribute is used (see <link linkend="bpmnJavaServiceTaskImplementation">further</link>).
         <programlisting> &lt;serviceTask id=&quot;serviceTask&quot; <emphasis role="bold">activiti:delegateExpression=&quot;${delegateExpressionBean}&quot;</emphasis> /&gt;</programlisting> 
         Here, the <literal>delegateExpressionBean</literal> is a bean that implements the <literal>JavaDelegate</literal> interface,
         defined in for example the Spring container.
       </para>
       
       <para>
         To specify a UEL method expression that should be evaluated, use 
         attribute <emphasis role="bold">activiti:expression</emphasis>.
<programlisting>
&lt;serviceTask id=&quot;javaService&quot; 
             name=&quot;My Java Service Task&quot; 
             activiti:expression=&quot;#{printer.printMessage()}&quot; /&gt;
</programlisting>
         Method <literal>printMessage</literal> (without parameters) will 
         be called on the named object called <literal>printer</literal>.
       </para>
       <para>
       	It's also possible to pass parameters with an method used in the expression.
       	<programlisting>
&lt;serviceTask id=&quot;javaService&quot; 
             name=&quot;My Java Service Task&quot; 
             activiti:expression=&quot;#{printer.printMessage(execution, myVar)}&quot; /&gt;
</programlisting>
		Method <literal>printMessage</literal> will be called on the object named <literal>printer</literal>. The first
		parameter passed is the <literal>DelegateExecution</literal>, which is available in the expression context by default
		available as <literal>expression</literal>. The second parameter passed, is the value of the variable with name <literal>myVar</literal>
		in the current execution. 
       </para>
       
       <para>
         To specify a UEL value expression that should be evaluated, use 
         attribute <emphasis role="bold">activiti:expression</emphasis>.
<programlisting>
&lt;serviceTask id=&quot;javaService&quot; 
             name=&quot;My Java Service Task&quot; 
             activiti:expression=&quot;#{split.ready}&quot; /&gt;
</programlisting>
         The getter method of property <literal>ready</literal>, <literal>getReady</literal> (without parameters), will 
         be called on the named bean called <literal>split</literal>.
         The named objects are resolved in the execution's process variables and 
         (if applicable) in the Spring context.
       </para>
       
     </section> 
     
     <section id="bpmnJavaServiceTaskImplementation">
     
      <title>Implementation</title>
      
      <para>
        To implement a class that can be called during process execution, this class needs to
        implement the <emphasis>org.activiti.engine.delegate.JavaDelegate</emphasis> interface and provide the required
        logic in the <emphasis>execute</emphasis> method. When process execution arrives
        at this particular step, it will execute this logic defined in that method and leave 
        the activity in the default BPMN 2.0 way.
      </para>  
      <para><link linkend="experimental"><emphasis role="bold">[EXPERIMENTAL]</emphasis></link>
        It is also possible to provide a class that implements the 
        <emphasis>org.activiti.engine.impl.pvm.delegate.ActivityBehavior</emphasis> interface.
        Implementations have then access to the more powerful <emphasis>ActivityExecution</emphasis>
        that for example also allows to influence the control flow of the process. Note however
        that this is not a very good practice, and should be avoided as much as possible.
        So, it is advised to use the <emphasis>ActivityBehavior</emphasis> interface only for 
        advanced use cases and if you know exactly what you're doing.
      </para>
      
      <para>
        Let's create for example a Java class that can be used to change a process variable String
        to uppercase. This class needs to implement the <emphasis>org.activiti.engine.delegate.JavaDelegate</emphasis>
        interface, which requires us to implement the <emphasis>execute(DelegateExecution)</emphasis>
        method. It's this operation that will be called by the engine and which needs to contain
        the business logic. Process instance information such as process variables  and other
        can be accessed and manipulated through the 
        <ulink url="http://activiti.org/javadocs/org/activiti/engine/delegate/DelegateExecution.html">DelegateExecution</ulink>
        interface (click on the link for a detailed Javadoc of its operations).
<programlisting>
public class ToUppercase implements JavaDelegate {
  
  public void execute(DelegateExecution execution) throws Exception {
    String var = (String) execution.getVariable(&quot;input&quot;);
    var = var.toUpperCase();
    execution.setVariable(&quot;input&quot;, var);
  }
  
}
</programlisting>
        </para>
        <para>
          Note: there will be <emphasis role="bold">only one instance of that Java class created for the serviceTask it is defined on</emphasis>.
          All process-instances share the same class instance that will be used to call <emphasis>execute(DelegateExecution)</emphasis>. 
          This means that the class must not use any member variables and must be thread-safe, since it can be executed simultaneously from different threads.
          This also influences the way <link linkend="serviceTaskFieldInjection">Field injection</link> is handled.
        </para>
        <para>
          The classes that are referenced in the process definition (ie by using <literal>activiti:class</literal>) are <emphasis role="bold">NOT
          instantiated during deployment</emphasis>. Only when a process execution arrives 
          for the first time at the point in the process where the class is used, an instance
          of that class will be created. If the class cannot be found, an <literal>ActivitiException</literal>
          will be thrown. The reasoning for this is that the environment (and more
          specifically the <emphasis>classpath</emphasis>) when you are deploying is often
          different from the actual runtime environment. For example when using <emphasis>ant</emphasis>
          or the business archive upload in Activiti Probe to deploy processes,
          the classpath does not contain the referenced classes.  
        </para>
     
     </section>
     
     <section id="serviceTaskFieldInjection">
     
      <title>Field injection</title>
      
        <para>
        It's possible to inject values into the fields of the delegated classes. The following types of injection are supported:
        <itemizedlist>
          <listitem><para>Fixed string values</para></listitem>
          <listitem><para>Expressions</para></listitem>
        </itemizedlist>
      </para>
      
        <para>
          The following code snippet shows how to inject a constant value into a field. Field injection
          is supported when using the <emphasis>'class'</emphasis> attribute.
          Note that we need to <emphasis role="bold">declare a 'extensionElements' XML element
          before the actual field injection declarations</emphasis>, which is a requirement of
          the BPMN 2.0 XML Schema.
          <programlisting>
&lt;serviceTask id=&quot;javaService&quot; 
    name=&quot;Java service invocation&quot; 
    activiti:class=&quot;org.activiti.examples.bpmn.servicetask.ToUpperCaseFieldInjected&quot;&gt;
    <emphasis role="bold">&lt;extensionElements&gt;
      &lt;activiti:field name=&quot;text&quot; stringValue=&quot;Hello World&quot; /&gt;
  &lt;/extensionElements&gt;</emphasis>           
&lt;/serviceTask&gt;        
          </programlisting>
          The class <literal>ToUpperCaseFieldInjected</literal> has a field <literal>text</literal> which is of type <literal>org.activiti.engine.impl.el.Expression</literal>. 
          When calling <literal>text.getValue(execution)</literal>, the configured string value <literal>Hello World</literal> will be returned.
        </para>
        <para>
          Alternatively, for longs texts (e.g. an inline e-mail) the <emphasis>'activiti:string'</emphasis>
          sub element can be used:
          <programlisting>
&lt;serviceTask id=&quot;javaService&quot; 
    name=&quot;Java service invocation&quot; 
    activiti:class=&quot;org.activiti.examples.bpmn.servicetask.ToUpperCaseFieldInjected&quot;&gt;
  &lt;extensionElements&gt;   
    &lt;activiti:field name=&quot;text&quot;&gt;
        <emphasis role="bold">&lt;activiti:string&gt;
          Hello World
      &lt;/activiti:string&gt;</emphasis>
    &lt;/activiti:field&gt;
  &lt;/extensionElements&gt;        
&lt;/serviceTask&gt;        
          </programlisting>
        </para>

        <para>
        To inject values that are dynamically resolved at runtime, expressions can be used. Those expressions can use process variables, or Spring defined beans (if Spring is used).
        As noted in <link linkend="bpmnJavaServiceTaskImplementation">Service Task Implementation</link>, an instance of the Java class is shared among all process-instances in a service task.
        To have dynamic injection of values in fields, you can inject value and method expressions in a <literal>org.activiti.engine.impl.el.Expression</literal> 
        which can be evaluated/invoked using the <literal>DelegateExecution</literal> passed in the <literal>execute</literal> method.
<programlisting>
&lt;serviceTask id=&quot;javaService&quot; name=&quot;Java service invocation&quot; 
  activiti:class=&quot;org.activiti.examples.bpmn.servicetask.ReverseStringsFieldInjected&quot;&gt;
  
  &lt;extensionElements&gt;
    &lt;activiti:field name=&quot;text1&quot;&gt;
      <emphasis role="bold">&lt;activiti:expression&gt;${genderBean.getGenderString(gender)}&lt;/activiti:expression&gt;</emphasis>
    &lt;/activiti:field&gt;
    &lt;activiti:field name=&quot;text2&quot;&gt;
       <emphasis role="bold">&lt;activiti:expression&gt;Hello ${gender == 'male' ? 'Mr.' : 'Mrs.'} ${name}&lt;/activiti:expression&gt;</emphasis>
    &lt;/activiti:field&gt;
  &lt;/ extensionElements&gt;
&lt;/ serviceTask&gt;
</programlisting>
  </para>
  <para>
  The example class below uses the injected expressions and resolves them using the current <literal>DelegateExecution</literal>.
  Full code and test can be found in <literal>org.activiti.examples.bpmn.servicetask.JavaServiceTaskTest.testExpressionFieldInjection</literal>
<programlisting>

public class ReverseStringsFieldInjected implements JavaDelegate {

  private Expression text1;
  private Expression text2;

  public void execute(DelegateExecution execution) {
    String value1 = (String) text1.getValue(execution);
    execution.setVariable("var1", new StringBuffer(value1).reverse().toString());

    String value2 = (String) text2.getValue(execution);
    execution.setVariable("var2", new StringBuffer(value2).reverse().toString());
  }
}
</programlisting>
  </para>
  <para>
  Alternatively, you can also set the expressions as an attribute instead of a child-element, to make the XML less verbose.
<programlisting>
&lt;activiti:field name=&quot;text1&quot; <emphasis role="bold">expression=&quot;${genderBean.getGenderString(gender)}&quot;</emphasis> /&gt;
&lt;activiti:field name=&quot;text1&quot; <emphasis role="bold">expression=&quot;Hello ${gender == 'male' ? 'Mr.' : 'Mrs.'} ${name}&quot;</emphasis> /&gt;
</programlisting>
        </para>
        <para>
          <emphasis role="bold">
            Since the Java class instance is reused, the injection only happens once, when the serviceTask is called the first time. When the fields are altered by your code,
            the values won't be re-injected so you should treat them as immutable and don't make any changes to them.
          </emphasis>
        </para>
     
     </section>

     <section id="serviceTaskResultValue">
         <title>Service task results</title>

         <para>
           The return value of a service execution (for service task using expression only) can be assigned to an already existing or to a new process variable by
           specifying the process variable name as a literal value for the <emphasis>'activiti:resultVariableName'</emphasis> attribute
           of a service task definition. Any existing value for a specific process variable will be overwritten by the result
           value of the service execution. When not specifying a result variable name, the service execution result value gets ignored.
<programlisting>
&lt;serviceTask id=&quot;aMethodExpressionServiceTask&quot;
    activiti:expression=&quot;#{myService.doSomething()}&quot;
    activiti:resultVariableName=&quot;myVar&quot; /&gt;
</programlisting>
             
           In the example above, the result of the service execution (the return value of the <emphasis>'doSomething()'</emphasis> method invocation on an object that is made available
           under the name <emphasis>'myService'</emphasis> either in the process variables or as a Spring bean) is set to the process variable named <emphasis>'myVar'</emphasis> after the service execution completes.
         </para>

     </section>
  		
		</section>
 <!--  
<section id="bpmnWebserviceTask">
	<title>WebService Task</title><link linkend="experimental">
		<emphasis role="bold">[EXPERIMENTAL]</emphasis>
	</link>

	<section id="bpmnWebserviceTaskDescription">

		<title>Description</title>

		<para>
			A WebService task is used to synchronously invoke an external web service.
		</para>

	</section>

	<section id="bpmnWebserviceTaskGraphicalNotation">

		<title>Graphical Notation</title>

		<para>
			A WebService task is visualized the same as a Java service task.
			<mediaobject>
				<imageobject>
					<imagedata align="center" fileref="images/bpmn.web.service.task.png" />
				</imageobject>
			</mediaobject>
		</para>

	</section>

	<section id="bpmnWebserviceTaskXML">

		<title>XML representation</title>

		<para>
			To use a WebService we need to import its operations and complex types. This can be done
			automatically by using the import tag pointing to the WSDL of the WebService:
       </para>

		<programlisting>
&lt;import importType=&quot;http://schemas.xmlsoap.org/wsdl/&quot;
	location=&quot;http://localhost:63081/counter?wsdl&quot;
	namespace=&quot;http://webservice.activiti.org/&quot; /&gt;</programlisting>
		
		<para>
			The previous declaration tells Activiti to import the definitions but it doesn't create
			the item definitions and messages for you. Let's suppose we want to invoke a specific method called
			'prettyPrint', therefore we will need to create the corresponding message and item definitions for
			the request and response messages:
		</para>

		<programlisting>
&lt;message id=&quot;prettyPrintCountRequestMessage&quot; itemRef=&quot;tns:prettyPrintCountRequestItem&quot; /&gt;
&lt;message id=&quot;prettyPrintCountResponseMessage&quot; itemRef=&quot;tns:prettyPrintCountResponseItem&quot; /&gt;
  
&lt;itemDefinition id=&quot;prettyPrintCountRequestItem&quot; structureRef=&quot;counter:prettyPrintCount&quot; /&gt;
&lt;itemDefinition id=&quot;prettyPrintCountResponseItem&quot; structureRef=&quot;counter:prettyPrintCountResponse&quot; /&gt;</programlisting>
		
		<para>
			Before declaring the service task, we have to define the BPMN interfaces and operations that actually reference the WebService ones.
			Basically, we define and 'interface' and the required 'operation's'. For each operation we reuse the previous defined
			message for in and out. For example, the following declaration defines the 'counter' interface and the 'prettyPrintCountOperation' operation:
		</para>
		
		<programlisting>
&lt;interface name=&quot;Counter Interface&quot; implementationRef=&quot;counter:Counter&quot;&gt;
	&lt;operation id=&quot;prettyPrintCountOperation&quot; name=&quot;prettyPrintCount Operation&quot; 
			implementationRef=&quot;counter:prettyPrintCount&quot;&gt;
		&lt;inMessageRef&gt;tns:prettyPrintCountRequestMessage&lt;/inMessageRef&gt;
		&lt;outMessageRef&gt;tns:prettyPrintCountResponseMessage&lt;/outMessageRef&gt;
	&lt;/operation&gt;
&lt;/interface&gt;</programlisting>
		
		<para>
			Then we can declare a WebService task by using the ##WebService implementation 
			and a reference to the WebService operation. 
		</para>
		
		<programlisting>
&lt;serviceTask id=&quot;webService&quot; 
	name=&quot;Web service invocation&quot;
	implementation=&quot;##WebService&quot;
	operationRef=&quot;tns:prettyPrintCountOperation&quot;&gt;</programlisting>
	</section>

	<section id="bpmnWebserviceTaskIOSpecification">
		<title>WebService task IO Specification</title>

		<para>
			Unless we are using the simplistic approach for data input and output associations (See below), each WebService task
			needs to declare an IO Specification which states which are the inputs and outputs of the task. The approach is pretty
			straightforward and BPMN 2.0 complaint, for our prettyPrint example we define the input and output sets according to
			the previously declared item definitions:  
		</para>
		
		<programlisting>
&lt;ioSpecification&gt;
	&lt;dataInput itemSubjectRef=&quot;tns:prettyPrintCountRequestItem&quot; id=&quot;dataInputOfServiceTask&quot; /&gt;
	&lt;dataOutput itemSubjectRef=&quot;tns:prettyPrintCountResponseItem&quot; id=&quot;dataOutputOfServiceTask&quot; /&gt;
	&lt;inputSet&gt;
		&lt;dataInputRefs&gt;dataInputOfServiceTask&lt;/dataInputRefs&gt;
	&lt;/inputSet&gt;
	&lt;outputSet&gt;
		&lt;dataOutputRefs&gt;dataOutputOfServiceTask&lt;/dataOutputRefs&gt;
	&lt;/outputSet&gt;
&lt;/ioSpecification&gt;</programlisting>
	</section>

	<section id="bpmnWebserviceTaskDataInputAssociation">
		<title>WebService task data input associations</title>

		<para>
			There are 2 ways of specifying data input associations:
		</para>
		
		<itemizedlist>
         	<listitem><para>Using expressions</para></listitem>
         	<listitem><para>Using the simplistic approach</para></listitem>
        </itemizedlist>
       
       <para>
       		To specify the data input association using expressions we need to define the source and target items
       		and specify the corresponding assignments between the fields of each item. In the following example we assign
       		prefix and suffix fields of the items:
       </para>
       
       <programlisting>
&lt;dataInputAssociation&gt;
	&lt;sourceRef&gt;dataInputOfProcess&lt;/sourceRef&gt;
	&lt;targetRef&gt;dataInputOfServiceTask&lt;/targetRef&gt;
	&lt;assignment&gt;
		&lt;from&gt;${dataInputOfProcess.prefix}&lt;/from&gt;
		&lt;to&gt;${dataInputOfServiceTask.prefix}&lt;/to&gt;
	&lt;/assignment&gt;
	&lt;assignment&gt;
		&lt;from&gt;${dataInputOfProcess.suffix}&lt;/from&gt;
		&lt;to&gt;${dataInputOfServiceTask.suffix}&lt;/to&gt;
	&lt;/assignment&gt;
&lt;/dataInputAssociation&gt;</programlisting>
       
       <para>
       		On the other hand we can use the simplistic approach which is much more simple. The 'sourceRef' element is an Activiti
       		variable name and the 'targetRef' element is a property of the item definition. In the following example we assign to
       		the 'prefix' field the value of the variable 'PrefixVariable' and to the 'suffix' field the value of the variable 'SuffixVariable'.
       </para>
       
       <programlisting>
&lt;dataInputAssociation&gt;
	&lt;sourceRef&gt;PrefixVariable&lt;/sourceRef&gt;
	&lt;targetRef&gt;prefix&lt;/targetRef&gt;
&lt;/dataInputAssociation&gt;
&lt;dataInputAssociation&gt;
	&lt;sourceRef&gt;SuffixVariable&lt;/sourceRef&gt;
	&lt;targetRef&gt;suffix&lt;/targetRef&gt;
&lt;/dataInputAssociation&gt;</programlisting>
	</section>

	<section id="bpmnWebserviceTaskDataOutputAssociation">
		<title>WebService task data output associations</title>

		<para>
			There are 2 ways of specifying data out associations:
		</para>
		
		<itemizedlist>
         	<listitem><para>Using expressions</para></listitem>
         	<listitem><para>Using the simplistic approach</para></listitem>
        </itemizedlist>
        
        <para>
       		To specify the data out association using expressions we need to define the target variable and the source expression. The approach is pretty
			straightforward and similar data input associations:
       </para>
       
       <programlisting>
&lt;dataOutputAssociation&gt;
	&lt;targetRef&gt;dataOutputOfProcess&lt;/targetRef&gt;
	&lt;transformation&gt;${dataOutputOfServiceTask.prettyPrint}&lt;/transformation&gt;
&lt;/dataOutputAssociation&gt;</programlisting>
       
       <para>
       		On the other hand we can use the simplistic approach which is much more simple. The 'sourceRef' element is a property
       		of the item definition and the 'targetRef' element is an Activiti variable name. The approach is pretty
			straightforward and similar data input associations: 
       </para>
       
       <programlisting>
&lt;dataOutputAssociation&gt;
	&lt;sourceRef&gt;prettyPrint&lt;/sourceRef&gt;
	&lt;targetRef&gt;OutputVariable&lt;/targetRef&gt;
&lt;/dataOutputAssociation&gt;</programlisting>
	</section>
</section>    

-->   
    
    <section id="executionListeners">
      <title>Execution listener</title>
      <para>Execution listeners allow you to execute external Java code or evaluate an expression when certain events occur
      during process exevcution. The events that can be captured are:
      <itemizedlist>
        <listitem><para>Start and ending of a process instance.</para></listitem>
        <listitem><para>Taking a transition.</para></listitem>
        <listitem><para>Start and ending of an activity.</para></listitem>
      </itemizedlist>
      </para>
      <para>
        The following process definition contains 3 execution listenerss:
        <programlisting>
  &lt;process id=&quot;executionListenersProcess&quot;&gt;
  
    <emphasis role="bold">&lt;extensionElements&gt;
      &lt;activiti:executionListener class=&quot;org.activiti.examples.bpmn.executionlistener.ExampleExecutionListenerOne&quot; event=&quot;start&quot; /&gt;
    &lt;/extensionElements&gt;</emphasis>
    
    &lt;startEvent id=&quot;theStart&quot; /&gt;
    &lt;sequenceFlow sourceRef=&quot;theStart&quot; targetRef=&quot;firstTask&quot; /&gt;
    
    &lt;userTask id=&quot;firstTask&quot; /&gt;
    &lt;sequenceFlow sourceRef=&quot;firstTask&quot; targetRef=&quot;secondTask&quot;&gt;
    <emphasis role="bold">&lt;extensionElements&gt;
      &lt;activiti:executionListener class=&quot;org.activiti.examples.bpmn.executionListener.ExampleExecutionListenerTwo&quot; /&gt;
    &lt;/extensionElements&gt;</emphasis>
    &lt;/sequenceFlow&gt;
    
    &lt;userTask id=&quot;secondTask&quot; &gt;
    <emphasis role="bold">&lt;extensionElements&gt;
      &lt;activiti:executionListener expression=&quot;${myPojo.myMethod(execution.event)}&quot; event=&quot;end&quot; /&gt;
    &lt;/extensionElements&gt;</emphasis>
    &lt;/userTask&gt;
    &lt;sequenceFlow sourceRef=&quot;secondTask&quot; targetRef=&quot;thirdTask&quot; /&gt;
       
    &lt;userTask id=&quot;thirdTask&quot; /&gt;
    &lt;sequenceFlow sourceRef=&quot;thirdTask&quot; targetRef=&quot;theEnd&quot; /&gt;

    &lt;endEvent id=&quot;theEnd&quot; /&gt;
    
  &lt;/process&gt;</programlisting>
        </para>
        <para>The first execution listener is notified when the process starts. The listener is an external Java-class (like <literal>ExampleExecutionListenerOne</literal>) 
        and should implement <literal>org.activiti.engine.impl.pvm.delegate.ExecutionListener</literal> interface. When the event occurs (in this case <literal>end</literal> event)
        the method <literal>notify(ExecutionListenerExecution execution)</literal> is called.
        <programlisting>
public class ExampleExecutionListenerOne implements <emphasis role="bold">ExecutionListener</emphasis> {

  <emphasis role="bold">public void notify(ExecutionListenerExecution execution) throws Exception {</emphasis>
    execution.setVariable("variableSetInExecutionListener", "firstValue");
    execution.setVariable("eventReceived", execution.getevent());
  }
}</programlisting>
        It is also possible to use a delegation class that implements the <literal>org.activiti.engine.delegate.JavaDelegate</literal>
        interface. These delegation classes can then be reused in other constructs, such as a delegation for a serviceTask.
        </para>
        <para>
           The second execution listener is called when the transition is taken. Note that the <literal>listener</literal> element doesn't define an
          <literal>event</literal>, since only <literal>take</literal> events are fired on transitions. 
          <emphasis role="bold">Values in the <literal>event</literal> attribute are ignored when a listener is defined on a transition.</emphasis>
        </para>
        <para>
          The last execution listener is called when activity <literal>secondTask</literal> ends. Instead of using the <literal>class</literal> on the listener declaration,
          a <literal>expression</literal> is defined instead which is evaluated/invoked when the event is fired. 
        </para>
        <programlisting>
&lt;activiti:executionListener expression=&quot;<emphasis role="bold">${myPojo.myMethod(execution.eventName)}</emphasis>&quot; event=&quot;end&quot; /&gt;</programlisting>
        <para>
          As with other expressions, execution variables are resolved and can be used. Because the execution implementation object has a property that exposes the event name, it's
          possible to pass the event-name to your methods using <literal>execution.eventName</literal>.
        </para>
        <para>
          Execution listeners also support using a <literal>delegateExpression</literal>,
          <link linkend="bpmnJavaServiceTaskXML">similar to a service task</link>.
          <programlisting>&lt;activiti:executionListener event=&quot;start&quot; delegateExpression=&quot;${myExecutionListenerBean}&quot; /&gt;</programlisting>         
        </para>
        
      <section id="executionListenerFieldInjection">
      
        <title>Field injection on execution listeners</title>
        <para>
         When using an execution listener that is configured with the <literal>class</literal> attribute, field injection can be applied. This is exactly the same
         mechanism as used <link linkend="serviceTaskFieldInjection">Service task field injection</link>, which contains an overview of the possibilities provided by field injection. 
        </para>
        <para>
         The fragment below shows a simple example process with an execution listener with fields injected. 
        <programlisting>
 &lt;process id=&quot;executionListenersProcess&quot;&gt;
    <emphasis role="bold">&lt;extensionElements&gt;
      &lt;activiti:executionListener class=&quot;org.activiti.examples.bpmn.executionListener.ExampleFieldInjectedExecutionListener&quot; event=&quot;start&quot;&gt;
        &lt;activiti:field name=&quot;fixedValue&quot; stringValue=&quot;Yes, I am &quot; /&gt;
        &lt;activiti:field name=&quot;dynamicValue&quot; expression=&quot;${myVar}&quot; /&gt;
      &lt;/activiti:executionListener&gt;
    &lt;/extensionElements&gt;</emphasis>
    
    &lt;startEvent id=&quot;theStart&quot; /&gt;
    &lt;sequenceFlow sourceRef=&quot;theStart&quot; targetRef=&quot;firstTask&quot; /&gt;
    
    &lt;userTask id=&quot;firstTask&quot; /&gt;
    &lt;sequenceFlow sourceRef=&quot;firstTask&quot; targetRef=&quot;theEnd&quot; /&gt;
    
    &lt;endEvent id=&quot;theEnd&quot; /&gt;
  &lt;/process&gt;
        </programlisting>
        </para>
        <para>
          <programlisting>
public class ExampleFieldInjectedExecutionListener implements ExecutionListener {

  <emphasis role="bold">private Expression fixedValue;

  private Expression dynamicValue;</emphasis>

  public void notify(ExecutionListenerExecution execution) throws Exception {
    execution.setVariable("var", <emphasis role="bold">fixedValue.getValue(execution).toString()</emphasis> + <emphasis role="bold">dynamicValue.getValue(execution).toString()</emphasis>);
  }
}
          </programlisting>
          The class <literal>ExampleFieldInjectedExecutionListener</literal> concatenates the 2 injected fields (one fixed an the other dynamic) and stores this in the process variable '<literal>var</literal>'.
        </para>
        <para>
        <programlisting>
@Deployment(resources = {"org/activiti/examples/bpmn/executionListener/ExecutionListenersFieldInjectionProcess.bpmn20.xml"})
public void testExecutionListenerFieldInjection() {
  Map&lt;String, Object&gt; variables = new HashMap&lt;String, Object&gt;();
  <emphasis role="bold">variables.put("myVar", "listening!");</emphasis>
    
  ProcessInstance processInstance = runtimeService.startProcessInstanceByKey("executionListenersProcess", variables);
    
  Object varSetByListener = runtimeService.getVariable(processInstance.getId(), "var");
  assertNotNull(varSetByListener);
  assertTrue(varSetByListener instanceof String);
    
  // Result is a concatenation of fixed injected field and injected expression
  <emphasis role="bold">assertEquals("Yes, I am listening!", varSetByListener);</emphasis>
}
        </programlisting>
        </para>
        </section>
         </section>
         
  <section id="taskListeners">
  
    <title>Task listener</title>
    
    <para>
      A <emphasis>task listener</emphasis> is used to execute custom Java logic or an expression
      upon the occurrence of a certain task-related event.
    </para>
    
    <para>
      A task listener can only be added in the process definition as a child element of a <link linkend="bpmnUserTask">user task</link>.
      Note that this also must happen as a child of the <emphasis>BPMN 2.0 extensionElements</emphasis>
      and in the <emphasis>activiti</emphasis> namespace, since a task listener is an Activiti-specific construct.      
      <programlisting>
&lt;userTask id=&quot;myTask&quot; name=&quot;My Task&quot; &gt;
  &lt;extensionElements&gt;
    <emphasis role="bold">&lt;activiti:taskListener event=&quot;create&quot; class=&quot;org.activiti.MyTaskCreateListener&quot; /&gt;</emphasis>
  &lt;/extensionElements&gt;
&lt;/userTask&gt;</programlisting>
      A <emphasis>task listener</emphasis> supports following attributes:
      <itemizedlist>
        <listitem>
          <para>
            <emphasis role="bold">event</emphasis> (required): the type of task event on which the task listener will
            be invoked. Possible values are <emphasis role="bold">'create'</emphasis> (occurs when the task 
            has been created an all task properties are set), <emphasis role="bold">'assignment'</emphasis> 
            (occurs when the task is assigned to somebody) or <emphasis role="bold">'complete'</emphasis>
            (occurs when the task is completed and just before the task is deleted from the runtime data).
          </para>
        </listitem>
        <listitem>
          <para>
            <emphasis role="bold">class</emphasis>: the delegation class that must be called. 
            This class must implement the <literal>org.activiti.engine.impl.pvm.delegate.TaskListener</literal>
            interface.
            <programlisting>
public class MyTaskCreateListener implements TaskListener {

  public void notify(DelegateTask delegateTask) {
    // Custom logic goes here
  }

}</programlisting>
            
            It is also possible to use <link linkend="serviceTaskFieldInjection">field injection</link> to pass
            process variables or the execution to the delegation class.
            Note that an instance of the delegation class is created upon process deployment
            (as is the case with any class delegation in Activiti), which means that the 
            instance is shared between all process instance executions.
          </para>
        </listitem>
        <listitem>
          <para>
            <emphasis role="bold">expression</emphasis>: (cannot be used together with the <emphasis>class</emphasis> attribute):
            specifies an expression that will be executed when the event happens. 
            It is possible to pass the <literal>DelegateTask</literal> object and the name
            of the event (using <literal>task.eventName</literal>) as parameter to the called object. 
            <programlisting>&lt;activiti:taskListener event=&quot;create&quot; expression=&quot;${myObject.callMethod(task, task.eventName)}&quot; /&gt;</programlisting>
          </para>
        </listitem>
        <listitem>
          <para>
            <emphasis role="bold">delegateExpression</emphasis> allows to specify an expression
            that resolves to an object implementing ther <literal>TaskListener</literal> interface,
            <link linkend="bpmnJavaServiceTaskXML">similar to a service task</link>. 
            <programlisting>&lt;activiti:taskListener event=&quot;create&quot; delegateExpression=&quot;${myTaskListenerBean}&quot; /&gt;</programlisting>        
          </para>
        </listitem>
      </itemizedlist>
    </para>
    
  </section>       
		
  <section id="bpmnEmailTask">
		
		  <title>Email task</title>
		  
		  <para>
		    Activiti allows to enhance business processes with automatic mail service tasks that send
		    e-mails to one or more recipients, including support for cc, bcc, html content, ... etc.
		    Note that the mail task is <emphasis role="bold">not</emphasis> an 'official' task 
		    of the BPMN 2.0 spec (and it does not have a dedicated icon as a consequence).
		    Hence, in Activiti the mail task is implemented as a dedicated service task.
		  </para>
		  
		  
		  <section id="bpmnEmailTaskServerConfiguration">
		  
		    <title>Mail server configuration</title>
		    
		    <para>
		      The Activiti engine sends e-mails trough an external mail server with SMTP capabilities.
		      To actually send e-mails, the engine needs to know how to reach the mail server.
		      Following properties can be set in the <emphasis>activiti.cfg.xml</emphasis> 
		      configuration file:
		      <table>
		        <title>Mail server configuration</title>
            <tgroup cols='3'>
            <thead>
              <row>
                <entry>Property</entry>
                <entry>Required?</entry>
                <entry>Description</entry>
              </row>
            </thead>
            <tbody>
		          <row>
		            <entry>mailServerHost</entry>
		            <entry>no</entry>
		            <entry>The hostname of your mail server (e.g. mail.mycorp.com). Default is <literal>localhost</literal></entry>
		          </row>
		          <row>
                <entry>mailServerPort</entry>
                <entry>yes, if not on the default port</entry>
                <entry>The port for SMTP traffic on the mail server. The default is <emphasis>25</emphasis></entry>
              </row>
              <row>
                <entry>mailServerDefaultFrom</entry>
                <entry>no</entry>
                <entry>The default e-mail address of the sender of e-mails, when none is provided by the user. By default this is <emphasis>activiti@activiti.org</emphasis></entry>
              </row>
              <row>
                <entry>mailServerUsername</entry>
                <entry>if applicable for your server</entry>
                <entry>Some mail servers require credentials for sending e-mail. By default not set.</entry>
              </row>
              <row>
                <entry>mailServerPassword</entry>
                <entry>if applicable for your server</entry>
                <entry>Some mail servers require credentials for sending e-mail. By default not set.</entry>
              </row>
            </tbody>
            </tgroup>
          </table>
		    </para>		  
		  
		  </section>
		  
		  <section id="bpmnEmailTaskUsage">
		  
		    <title>Defining an Email Task</title>
		    
		    <para>
		      The Email task is implemented as a dedicated <link linkend="bpmnJavaServiceTask">Service Task</link>
		      and is defined by setting <emphasis>'mail'</emphasis> for the <emphasis>type</emphasis> of the service task.
		      <programlisting>
&lt;serviceTask id=&quot;sendMail&quot; <emphasis role="bold">activiti:type=&quot;mail&quot;</emphasis>&gt;		      
		      </programlisting>
		    </para>
		    
        <para>
		      The Email task is configured by <link linkend="serviceTaskFieldInjection">field injection</link>.
		      All the values for these properties can contain EL expression, which are resolved at runtime
		      during process execution.
		      Following properties can be set:
		      <table>
	         <title>Mail server configuration</title>
	         <tgroup cols='3'>
	           <thead>
	             <row>
	               <entry>Property</entry>
	               <entry>Required?</entry>
	               <entry>Description</entry>
	             </row>
	           </thead>
	           <tbody>
	             <row>
	               <entry>to</entry>
	               <entry>yes</entry>
	               <entry>The recipients if the e-mail. Multiple recipients are defined in a comma-separated list</entry>
	             </row>
	             <row>
                 <entry>from</entry>
                 <entry>no</entry>
                 <entry>The sender e-mail address. If not provided, the <link linkend="bpmnEmailTaskServerConfiguration">default configured</link> from address is used.</entry>
               </row>
                <row>
                 <entry>subject</entry>
                 <entry>no</entry>
                 <entry>The subject of the e-mail.</entry>
               </row>
                <row>
                 <entry>cc</entry>
                 <entry>no</entry>
                 <entry>The cc's of the e-mail. Multiple recipients are defined in a comma-separated list</entry>
               </row>
                <row>
                 <entry>bcc</entry>
                 <entry>no</entry>
                 <entry>The bcc's of the e-mail. Multiple recipients are defined in a comma-separated list</entry>
               </row>
                <row>
                 <entry>html</entry>
                 <entry>no</entry>
                 <entry>A piece of HTML that is the content of the e-mail.</entry>
               </row>
               <row>
                 <entry>text</entry>
                 <entry>no</entry>
                 <entry>The content of the e-mail, in case one needs to send plain none-rich e-mails.
                   Can be used in combination with <emphasis>html</emphasis>, for e-mail clients
                   that don't support rich content. The client will then fall back to this text-only alternative.
                 </entry>
               </row>
             </tbody>
	         </tgroup>
	        </table>
        </para>
        
		  </section>
		  
		  <section id="bpmnEmailTaskExampleUsage">
		  
		    <title>Example usage</title>
		  
		  
		    <para>
		      The following XML snippet shows an example of using the Email Task.
		      <programlisting>
&lt;serviceTask id=&quot;sendMail&quot; activiti:type=&quot;mail&quot;&gt;
  &lt;extensionElements&gt;
    &lt;activiti:field name=&quot;from&quot; stringValue=&quot;order-shipping@thecompany.com&quot; /&gt;
    &lt;activiti:field name=&quot;to&quot; expression=&quot;${recipient}&quot; /&gt;
    &lt;activiti:field name=&quot;subject&quot; expression=&quot;Your order ${orderId} has been shipped&quot; /&gt;
    &lt;activiti:field name=&quot;html&quot;&gt;
      &lt;activiti:expression&gt;
        &lt;![CDATA[
          &lt;html&gt;
            &lt;body&gt;
              Hello ${male ? 'Mr.' : 'Mrs.' } ${recipientName},&lt;br/&gt;&lt;br/&gt;
                 
              As of ${now}, your order has been &lt;b&gt;processed and shipped&lt;/b&gt;.&lt;br/&gt;&lt;br/&gt;
                  
              Kind regards,&lt;br/&gt;
                  
              TheCompany.
            &lt;/body&gt;
          &lt;/html&gt;
        ]]&gt;
      &lt;/activiti:expression&gt;
    &lt;/activiti:field&gt;      
  &lt;/extensionElements&gt;
&lt;/serviceTask&gt;		      
		      </programlisting>
		      with the following result:
		      <mediaobject><imageobject><imagedata align="center" fileref="images/email.task.result.png"/></imageobject></mediaobject>
		    </para>
		  </section>
		
		</section>
		
		<section id="bpmnManualTask">
		
		  <title>Manual Task</title>
		  
		  <section id="bpmnManualTaskDescription">
		  
		    <title>Description</title>
		    
		    <para>
		      A <emphasis>Manual Task</emphasis> defines a task that is external to the BPM engine.
		      It is used to model work that is done by somebody, which the engine
		      does not need to know of, nor is there a system or UI interface.
		      For the engine, a manual task is handled as a <emphasis role="bold">pass-through activity</emphasis>,
		      automatically continuing the process from the moment process execution arrives into it.
		    </para>
		  
		  </section>
		  
		  <section id="bpmnManualTaskGraphicalNotation">
		  
		    <title>Graphical Notation</title>
		    
		    <para>
		      A manual task is visualized as a rounded rectangle, with a little 'hand' icon 
		      in the upper left corner
		      <mediaobject><imageobject><imagedata align="center" fileref="images/bpmn.manual.task.png"/></imageobject></mediaobject>
		    </para>
		  
		  </section>
		  
		  <section id="bpmnManualTaskXml">
		  
		    <title>XML representation</title>
		    
		    <para>
		      <programlisting>&lt;manualTask id=&quot;myManualTask&quot; name=&quot;Call client for more information&quot; /></programlisting>
		    </para>
		  
		  </section>
		
		</section>
		
		<section id="bpmnReceiveTask">
		
		  <title>Java receive task</title>
		  
		  <section id="bpmnReceiveTaskDescription">
		  
		    <title>Description</title>
		    
		    <para>
          A receive task is a simple task that waits for the arrival of a certain message.
          Currently, we have only implemented Java semantics for this task. When process
          execution arrives at a receive task, the process state is committed to the 
          persistence store. This means that the process will stay in this wait state, 
          until a specific message is received by the engine, which triggers the continuation
          of the process past the receive task.
		    </para>
		  
		  </section>
		  
		  <section>
		  
		    <title>Graphical notation</title>
        
        <para>
          A receive task is visualized as a task (rounded rectangle) with a message icon in
          the top left corner. The message is white (a black message icon would have send semantics)
          <mediaobject><imageobject><imagedata align="center" fileref="images/bpmn.receive.task.png"/></imageobject></mediaobject>
        </para>
      
      </section>
      
      <section>
      
        <title>XML representation</title>
        
        <para>
          <programlisting>&lt;receiveTask id=&quot;waitState&quot; name=&quot;wait&quot; />    </programlisting>
        </para>
        
        <para>
          To continue a process instance that is currently waiting at such a receive task,
          the <emphasis>runtimeService.signal(executionId)</emphasis> must be called using
          the id of the execution that arrived in the receive task.
          The following code snippet shows how this works in practice:
          <programlisting>
ProcessInstance pi = runtimeService.startProcessInstanceByKey(&quot;receiveTask&quot;);
Execution execution = runtimeService.createExecutionQuery()
  .processInstanceId(pi.getId())
  .activityId(&quot;wait&quot;)
  .singleResult();
assertNotNull(execution);
    
<emphasis role="bold">runtimeService.signal(execution.getId());</emphasis>   
          </programlisting>
        </para>
      
      </section>
		
		</section>
		
		<section id="bpmnBoundaryEvent">
		  
		  <title>Boundary events</title>
		  
		  <para>
		    Boundary events are <emphasis>catching</emphasis> events that are attached to an activity
		    (a boundary event can never be throwing). This means that while the activity is
		    running, the event is <emphasis>listening</emphasis> for a certain type of trigger. 
		    When the event is <emphasis>caught</emphasis>, the activity is interrupted and the 
		    sequence flow going out of the event are followed.
		  </para>
		  
		  <para>
		    All boundary events are defined in the same way:
<programlisting>
&lt;boundaryEvent id=&quot;myBoundaryEvent&quot; attachedToRef=&quot;theActivity&quot;&gt;
      &lt;XXXEventDefinition/&gt;
&lt;/boundaryEvent&gt;</programlisting>
		  </para>
		  
		  <para>
		    A boundary event is defined with
		    <itemizedlist>
		      <listitem>
		        <para>
		          A unique identifier (process-wide)
		        </para>
		      </listitem>
		      <listitem>
		        <para>
		          A reference to the activity to which the event is attached through the
		          <emphasis role="bold">attachedToRef</emphasis> attribute.
		          Note that a boundary event is defined on the same level as the activities
		          to which they are attached
		          (i.e. no inclusion of the boundary event inside the activity).
		        </para>
		      </listitem>
		      <listitem>
		        <para>
		          An XML sub-element of the form <emphasis>XXXEventDefinition</emphasis> 
		          (e.g. <emphasis>TimerEventDefinition</emphasis>, <emphasis>ErrorEventDefinition</emphasis>, etc.)
		          defining the type of the boundary event. See the specific boundary event types
		          for more details.
		        </para>
		      </listitem>
		    </itemizedlist>
		  </para>
		  
		</section>
		  
		<section id="bpmnTimerBoundaryEvent">
      
      <title>Timer Boundary Event</title>
        
      <section id="timerBoundaryEventDescription">
        
        <title>Description</title>
          
        <para>
          A timer boundary event acts as a stopwatch and alarm clock. When an execution arrives
          in the activity where the boundary event is attached to, a timer is started.
          When the timer fires (e.g. after a specified interval), the activity is interrupted
          and the sequence flow going out of the timer boundary event are followed.
        </para>
        
      </section>
        
      <section id="bpmnTimerBoundaryEventGraphicalNotation">
        
        <title>Graphical Notation</title>
          
        <para>
          A timer boundary event is visualized as a typical boundary event (i.e. circle
          on the border), with the timer icon on the inside.
          <mediaobject><imageobject><imagedata align="center" fileref="images/bpmn.boundary.timer.event.png"/></imageobject></mediaobject>
        </para>
        
      </section>
      
      <section id="bpmnTimerBoundaryEventXml">
      
        <title>XML Representation</title>
        
        <para>
          A timer boundary event is defined as a <link linkend="bpmnBoundaryEvent">regular boundary event</link>.
          The specific type sub-element is in this case a <emphasis role="bold">timerEventDefinition</emphasis>
          element.
<programlisting>
&lt;boundaryEvent id=&quot;escalationTimer&quot; cancelActivity=&quot;true&quot; attachedToRef=&quot;firstLineSupport&quot;&gt;
   <emphasis role="bold">&lt;timerEventDefinition&gt;
    &lt;timeDuration&gt;PT4H&lt;/timeDuration&gt;
  &lt;/timerEventDefinition&gt;</emphasis>
&lt;/boundaryEvent&gt;          
</programlisting>
        </para>
        
        <para>
          To specify how long the timer should run before it is fired, a <emphasis>timeDuration</emphasis>
          can be specified as sub-element of <emphasis>timerEventDefinition</emphasis>. The format
          used is the <ulink url="http://en.wikipedia.org/wiki/ISO_8601#Durations">ISO 8601</ulink>
          format (as required by the BPMN 2.0 specification).
        </para>
        
        <para>
          <emphasis role="bold">Note:</emphasis> boundary timer events are only fired when 
          the job executor is enabled (i.e. <emphasis>jobExecutorActivate</emphasis>
          needs to be set to <literal>true</literal> in the <literal>activiti.cfg.xml</literal>, since the job
          executor is disabled by default). 
        </para>
      
      </section>
      
      <section id="bpmnKnownIssueBoundaryEvent">
    
      <title>Known issue with boundary events</title>
      
      <para>
        There is a known issue regarding concurrency when using boundary events of any type.
        Currently, it is not possible to have multiple outgoing sequence flow attached to 
        a boundary event (see issue <ulink url="http://jira.codehaus.org/browse/ACT-47">ACT-47</ulink>).
        A solution to this problem is to use one outgoing sequence flow that goes to a parallel gateway.
        <mediaobject><imageobject><imagedata align="center" fileref="images/bpmn.known.issue.boundary.event.png"/></imageobject></mediaobject>
      </para>
    
    </section>
		
		</section> 
		
		<section id="bpmnSubProcess">
		
		  <title>SubProcess</title>
		  
		  <section id="bpmnSubProcessDescription">
		  
		    <title>Description</title>
		    
		    <para>
		      A <emphasis>subprocess</emphasis> is an activity that contains other activities, gateways,
		      events, etc. which on itself form a process that is part of the bigger process. 
		      A <emphasis>subprocess</emphasis> is completely defined inside a parent process
		      (that's why it's often called an <emphasis>embedded</emphasis> subprocess).
		    </para>
		    
		    <para>
		      Subprocesses have two major use cases:
		      <itemizedlist>
		        <listitem>
		          <para>
		            Subprocesses allow <emphasis role="bold">hierarchical modeling</emphasis>.
		            Many modeling tools allow that subprocesses can be <emphasis>collapsed</emphasis>, 
		            hiding all the details of the subprocess and displaying a high-level end-to-end
		            overview of the business process.
		          </para>
		        </listitem>
		        <listitem>
		          <para>
		            A subprocess creates a new <emphasis role="bold">scope for events</emphasis>.
		            Events that are thrown during execution of the subprocess, can be caught by
		            <link linkend="bpmnBoundaryEvent">a boundary event</link> on the boundary 
		            of the subprocess, thus creating a scope for that event limited to the subprocess.
		          </para>
		        </listitem>
		      </itemizedlist>
		    </para>
		    
		    <para>
		      Using a subprocess does impose some constraints:
		      <itemizedlist>
		        <listitem>
		          <para>
		            A subprocess can only have <emphasis role="bold">one none start event</emphasis>, no other
		            start event types are allowed. A subprocess must <emphasis role="bold">
		            at least have one end event</emphasis>. Note that the BPMN 2.0 specification
		            allows to omit the start and end events in a subprocess, but the current
		            Activiti implementation does not support this.
		          </para>
		        </listitem>
		        <listitem>
		          <para>
		            <emphasis role="bold">Sequence flow can not cross subprocess boundaries.</emphasis>
		          </para>
		        </listitem>
		      </itemizedlist>
		    </para>
		  
		  </section>
		  
		  <section id="bpmnSubProcessGraphicalNotation">
      
        <title>Graphical Notation</title>
        
        <para>
          A subprocess is visualized as a typical activity, i.e. a rounded rectangle.
          In case the subprocess is <emphasis>collapsed</emphasis>, only the name and a plus-sign are displayed,
          giving a high-level overview of the process:
          <mediaobject><imageobject><imagedata align="center" fileref="images/bpmn.collapsed.subprocess.png"/></imageobject></mediaobject>
        </para>
        
        <para>  
          In case the subprocess is <emphasis>expanded</emphasis>, the steps of the subprocess
          are displayed within the subprocess boundaries:
          <mediaobject><imageobject><imagedata align="center" fileref="images/bpmn.expanded.subprocess.png"/></imageobject></mediaobject>
        </para>
        
        <para>
          One of the main reasons to use a subprocess, is to define a scope for a certain event.
          The following process model shows this: both the <emphasis>investigate software/investigate hardware</emphasis>
          tasks need to be done in parallel, but both tasks need to be done within a certain time,
          before <emphasis>Level 2 support</emphasis> is consulted.
          Here, the scope of the timer (i.e. which activities must be done in time) is constrained by the subprocess. 
          <mediaobject><imageobject><imagedata align="center" fileref="images/bpmn.subprocess.with.boundary.timer.png"/></imageobject></mediaobject>
        </para>
      
      </section>
      
      <section id="bpmnSubProcessXML">
      
        <title>XML representation</title>
        
        <para>
          A subprocess is defined by the <emphasis>subprocess</emphasis> element.
          All activities, gateways, events, etc. that are part of the subprocess, need
          to be enclosed within this element.
          <programlisting>
&lt;subProcess id=&quot;subProcess&quot;&gt;
    
  &lt;startEvent id=&quot;subProcessStart&quot; /&gt;
  
  ... other subprocess elements ...

  &lt;endEvent id=&quot;subProcessEnd&quot; /&gt;
    
 &lt;/subProcess&gt;          
          </programlisting> 
        </para>
      
      </section>
		
		</section>
		
		<section id="bpmnCallActivity">
		
		  <title>Call activity (subprocess)</title>
		  
		  <section id="bpmnCallActivityDescription">
		  
		    <title>Description</title>
		    
		    <para>
		      BPMN 2.0 makes a distinction between a regular <emphasis><link linkend="bpmnSubProcess">subprocess</link></emphasis>,
		      often also called <emphasis>embedded subprocess</emphasis>, and the call activity, which
		      looks very similar. From a conceptual point of view, both will call a subprocess when
		      process execution arrives at the activity.
		    </para>
		    
		    <para>
		      The difference is that the call activity references a process that is external to
		      the process definition, whereas the <emphasis><link linkend="bpmnSubProcess">subprocess</link></emphasis>
		      is embedded within the original process definition. The main use case for the call
		      activity is to have a reusable process definition that can be called from multiple
		      other process definitions.
		    </para>
		    
		    <para>
		      When process execution arrives in the <emphasis>call activity</emphasis>, a new 
		      execution is created that is a sub-execution of the execution that arrives in the
		      call activity. This sub-execution is then used to execute the subprocess, potentially
		      creating parallel child execution as within a regular process. The super-execution
		      waits until the subprocess is completely ended, and continues the original 
		      process afterwards.
		    </para>
		    
		  </section>
		  
		  <section id="bpmnCallActivityGraphicalNotation">
      
        <title>Graphical Notation</title>
        
        <para>
          A call activity is visualized the same as a <link linkend="bpmnSubProcessGraphicalNotation">subprocess</link>,
          however with a thick border (collapsed and expanded).
          Depending on the modeling tool, a call activity can also be expanded, but the default
          visualization is the collapsed subprocess representation.
          <mediaobject><imageobject><imagedata align="center" fileref="images/bpmn.collapsed.call.activity.png"/></imageobject></mediaobject>
        </para>
        
      </section>
      
      <section id="bpmnCallActivityXMLRepresentation">
      
        <title>XML representation</title>
        
        <para>
          A call activity is a regular activity, that requires a <emphasis>calledElement</emphasis>
          that references a process definition by its <emphasis role="bold">key</emphasis>.
          In practice, this means that the <emphasis role="bold">id of the process</emphasis> is
          used in the <emphasis>calledElement</emphasis>.
<programlisting>
&lt;callActivity id=&quot;callCheckCreditProcess&quot; name=&quot;Check credit&quot; calledElement=&quot;checkCreditProcess&quot; /&gt;
</programlisting>
        </para>
        
        <para>
          Note that the process definition of the subprocess is <emphasis role="bold">resolved 
          at runtime</emphasis>. This means that the subprocess can be deployed independently
          from the calling process, if needed.
        </para>
        
      </section>
      
      <section id="bpmnCallActivityExample">
      
        <title>Example</title>
        
        <para>
          The following process diagram shows a simple handling of an order. Since the
          checking of the customer's credit could be common to many other processes, the 
          <emphasis>check credit step</emphasis> is modeled here as a call activity.
          <mediaobject><imageobject><imagedata align="center" fileref="images/bpmn.call.activity.super.process.png"/></imageobject></mediaobject>
          The process looks as follows:
<programlisting>
&lt;startEvent id=&quot;theStart&quot; /&gt;
&lt;sequenceFlow id=&quot;flow1&quot; sourceRef=&quot;theStart&quot; targetRef=&quot;receiveOrder&quot; /&gt;

&lt;manualTask id=&quot;receiveOrder&quot; name=&quot;Receive Order&quot; /&gt;
&lt;sequenceFlow id=&quot;flow2&quot; sourceRef=&quot;receiveOrder&quot; targetRef=&quot;callCheckCreditProcess&quot; /&gt;
    
<emphasis role="bold">&lt;callActivity id=&quot;callCheckCreditProcess&quot; name=&quot;Check credit&quot; calledElement=&quot;checkCreditProcess&quot; /&gt;</emphasis>
&lt;sequenceFlow id=&quot;flow3&quot; sourceRef=&quot;callCheckCreditProcess&quot; targetRef=&quot;prepareAndShipTask&quot; /&gt;
   
&lt;userTask id=&quot;prepareAndShipTask&quot; name=&quot;Prepare and Ship&quot; /&gt;
&lt;sequenceFlow id=&quot;flow4&quot; sourceRef=&quot;prepareAndShipTask&quot; targetRef=&quot;end&quot; /&gt;
    
&lt;endEvent id=&quot;end&quot; /&gt;
</programlisting>
          The subprocess looks as follows:
          <mediaobject><imageobject><imagedata align="center" fileref="images/bpmn.call.activity.sub.process.png"/></imageobject></mediaobject>
          There is nothing special to the process definition of the subprocess. It could as well
          be used without being called from another process.
        </para>
      
      </section>
		
		</section>

	</section>

</chapter>
