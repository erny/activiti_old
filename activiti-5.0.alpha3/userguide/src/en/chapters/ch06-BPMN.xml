<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "../../../target/docbook-tool-1.0/docbook-xml/docbookx.dtd">

<chapter id="bpmn20">
	<title>BPMN</title>

	<section id="whatIsBpmn">

		<title>What is BPMN?</title>

		<para>
		  See our <ulink url="http://activiti.org/faq.html#WhatIsBbpm20">FAQ entry on BPMN 2.0</ulink>
		</para>

	</section>

  <!-- Commented 06/05/2010: currently no focus on multiple languages support 
  
	<section id="bpmnConfiguration">

		<title>Configuration</title>

		<para>
		  The Activiti engine is capable of running mutliple process languages, due to its
		  Process Virtual Machine (PVM) design. Currently, we've implemented the BPMN 2.0,
		  but the mechanism described here for enabling a certain process language will be the same.
		</para>
		
		<para>
		  To enable BPMN 2.0 support, add the following lines to 
      the Activiti <emphasis role="bold">configuration file</emphasis> (default this is
      <emphasis>activiti.cfg.xml</emphasis>).
      
      <programlisting>
&lt;object name=&quot;DeployerManager&quot; class=&quot;org.activiti.impl.repository.DeployerManager&quot;&gt;
  &lt;property name=&quot;deployers&quot;&gt;
    &lt;list&gt;
      <emphasis role="bold">&lt;object class=&quot;org.activiti.impl.bpmn.BpmnDeployer&quot; /&gt;</emphasis>
    &lt;/list&gt;
  &lt;/property&gt;
&lt;/object&gt;</programlisting>  
		</para>
		
		<para>
		  This will add a BPMN 2.0 process deployer (implementation of the
		  <emphasis>org.activiti.impl.repository.Deployer</emphasis> interface) to the 
		  <emphasis>DeployManager</emphasis> of the engine. 
		</para>

	</section>
	-->
	
	<section id="bpmnExamples">

		<title>Examples</title>

		<para>
		  Examples for the BPMN 2.0 constructs described in the following sections can be 
		  found in the <emphasis>docs/examples</emphasis> folder. 
	  </para>
	  
	  <para>	  
		  See the specific section on <link linkend="examples">examples</link> for more information.
		</para>

	</section>

	<section id="bpmnDefiningProcess">

		<title>Defining a process</title>

		<para>
      To create a new BPMN 2.0 process definition, it's best to have your Eclipse
      <link linkend="examples">properly set up</link>.		  
		</para>
		
		<para>
		  Create a new XML file (<emphasis>New->Other->XML-XML</emphasis>) and give it a name.
		  Make sure that the file <emphasis role="bold">ends with .bpmn.xml</emphasis>, since
		  otherwise the engine won't pick up this file for deployment.
		  <mediaobject><imageobject><imagedata align="center" fileref="images/new.bpmn.procdef.png"/></imageobject></mediaobject>
		</para>
		
		<para>
		  The root element of the BPMN 2.0 schema is the <emphasis role="bold">definitions</emphasis> element.
		  Within this element, multiple process definitions can be defined (altough we advise to have only one
		  process definition in each file, since this simplifies maintenance later in the development process).
		  An empty process definition looks as follows. Note that the minimal definitions element
		  only needs the <emphasis>xmlns</emphasis> and <emphasis>targetNamespace</emphasis> declaration.
		  <programlisting>
&lt;definitions 
  xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
  xmlns=&quot;http://www.omg.org/spec/BPMN/20100524/MODEL&quot;
  xsi:schemaLocation=&quot;http://schema.omg.org/spec/BPMN/2.0 BPMN20.xsd&quot; 
  typeLanguage=&quot;http://www.w3.org/2001/XMLSchema&quot;
  expressionLanguage=&quot;http://www.w3.org/1999/XPath&quot; 
  targetNamespace=&quot;http://www.activiti.org/bpmn2.0&quot;&gt;

  &lt;process id=&quot;myProcess&quot; name=&quot;My First Process&quot;&gt;

  &lt;/process&gt;

&lt;/definitions&gt;</programlisting>
		</para>
		
		<para>
		  Note at the xml namespace that we are using the latest beta version of the 
		  BPMN 2.0 specification, released on 
		  <ulink url="http://www.omgwiki.org/bpmn2.0-ftf/doku.php?id=public:report">May 2010</ulink>.
		</para>
		
		<para>
		  The process element has two attributes:
		  <itemizedlist>
		    <listitem>
		      <para>
		        <emphasis role="bold">id</emphasis>: this attribute is <emphasis role="bold">required</emphasis>
		        and maps to the <emphasis role="bold">key</emphasis> property of an Activiti <emphasis>
		        ProcessDefinition</emphasis> object.
		        This id can then be used to start a new process instance of the process definition, through the 
		        <emphasis>startProcessInstanceByKey</emphasis> method on the <emphasis>ProcessService</emphasis>.
		        This method will always take the <emphasis role="bold">latest deployed version</emphasis>
		        of the process definition.
		        <programlisting>
ProcessInstance processInstance = processService.startProcessInstanceByKey(&quot;<emphasis role="bold">myProcess</emphasis>&quot;);</programlisting>
		        Important to note here is that this is not the same as calling the 
		        <emphasis>startProcessInstanceById</emphasis> method. This method expects the String id 
		        that was generated at deploy time by the Activiti engine, and can be retrieved by calling the
		        <emphasis>processDefinition.getId()</emphasis> method.
		      </para>
		    </listitem>
		    <listitem>
          <para>
            <emphasis role="bold">name</emphasis>: this attribute is <emphasis role="bold">optional</emphasis>
            and maps to the <emphasis>name</emphasis> property of a <emphasis>ProcessDefinition</emphasis>.
            The engine itself doesn't use this property, so it can for example be used for displaying a more
            human-friendly name in a UI.
          </para>
        </listitem>
		  </itemizedlist>
		</para>

	</section>
	
	<section id="10minutetutorial">
	
    <title>Getting started: 10 minute tutorial</title>
    
    <para>
      In this section we will cover a (simple) business process that we will use to introduce
      some basic Activiti concepts and the Activiti API. 
    </para>
    
    <section id="bpmnFirstExampleUseCase">
      
      <title>Use case</title>
      
      <para>
				The use case is very simple: we have a company, let's call it BPMCorp.
				In BPMCorp, a financial report needs to be written every month for the
				company shareholders. This is the responsibility of the accountancy
				department. When the report is finished, one of the members of the
				upper management needs to approve the document before it is sent to all
				the shareholders.
      </para> 
      
      <para>
        All files and code snippets used through the next sections can be found
        in the <link linkend="examples">examples</link> shipped with the Activiti distribution.
        Look for the package <emphasis>org.activiti.examples.bpmn.task</emphasis>.
      </para>   
    
    </section>
    
    <section id="bpmnFirstExampleDiagram">
    
      <title>Process diagram</title>
    
      <para>
				The business process as described above, can be graphically visualized
				using the Activiti Modeler. The end result, in BPMN 2.0 notation, looks
				like this:
			  <mediaobject><imageobject><imagedata align="center" fileref="images/financial.report.example.diagram.png"/></imageobject></mediaobject>
        There is nothing spectaular here. What we see is a <link linkend="bpmnNoneStartEvent">none start event</link> (circle on the left),
        followed by two <link linkend="bpmnUserTask">user tasks</link>:
        <emphasis>'Write monthly financialreport'</emphasis> and 
        <emphasis>'Verify monthly financial report'</emphasis>, ending in
        a <link linkend="bpmnNoneEndEvent">none end event</link> (circle with thick border on the right).
      </para>
    
    </section>
    
    <section id="bpmnFirstExampleXml">
    
      <title>XML representation</title>
      
      <para>
        The XML version of this business process (<emphasis>financial_report_process.bpmn20.xml</emphasis>) looks as shown below.
        It's easy to recognize the main elements of our process (click on the links
        for going to the detailed section of that BPMN 2.0 construct):
        <itemizedlist>
          <listitem>
            <para>
              The <link linkend="bpmnNoneStartEvent">(none) start event</link>
              learns us where to start with the process
            </para>
          </listitem>
          <listitem>
            <para>
              The <link linkend="bpmnUserTask">user tasks</link> declarations are the representation
              of the human tasks of our process. Note that the first task is assigned
              to the <emphasis>accountancy</emphasis> group, while the second task is 
              assigned to the <emphasis>management</emphasis> group.
              See <link linkend="bpmnUserTaskAssignment">the section on user task assignment</link>
              for more information on how users and groups can be assigned
              to user tasks.
            </para>
          </listitem>
          <listitem>
            <para>
              The process ends when the <link linkend="bpmnNoneEndEvent">none end event</link>
              is reached.
            </para> 
          </listitem>
        </itemizedlist>
        <programlisting>
&lt;process id=&quot;financialReport&quot; name=&quot;Monthly financial report reminder process&quot;&gt;
  
  &lt;startEvent id=&quot;theStart&quot; /&gt;
    
  &lt;sequenceFlow id='flow1' sourceRef='theStart' targetRef='writeReportTask' /&gt;
    
  &lt;userTask id=&quot;writeReportTask&quot; name=&quot;Write monthly financial report&quot; &gt;
    &lt;documentation&gt;
      Write monthly financial report for publication to shareholders.
    &lt;/documentation&gt;
    &lt;potentialOwner&gt;
      &lt;resourceAssignmentExpression&gt;
        &lt;formalExpression&gt;accountancy&lt;/formalExpression&gt;
      &lt;/resourceAssignmentExpression&gt;
    &lt;/potentialOwner&gt;
  &lt;/userTask&gt;
    
  &lt;sequenceFlow id='flow2' sourceRef='writeReportTask' targetRef='verifyReportTask' /&gt;
      
  &lt;userTask id=&quot;verifyReportTask&quot; name=&quot;Verify monthly financial report&quot; &gt;
    &lt;documentation&gt;
      Verify monthly financial report composed by the accountancy departement.
      This financial report is going to be sent to all the company shareholders.  
    &lt;/documentation&gt;
    &lt;potentialOwner&gt;
      &lt;resourceAssignmentExpression&gt;
        &lt;formalExpression&gt;management&lt;/formalExpression&gt;
      &lt;/resourceAssignmentExpression&gt;
    &lt;/potentialOwner&gt;
  &lt;/userTask&gt;
    
  &lt;sequenceFlow id='flow3' sourceRef='verifyReportTask' targetRef='theEnd' /&gt;
      
  &lt;endEvent id=&quot;theEnd&quot; /&gt;
      
&lt;/process&gt;</programlisting>        
      </para>
    
    </section>
    
    <section id="bpmnFirstExamplStartProcess">
    
      <title>Starting a process instance</title>
      
      <para>
        We now have defined the <emphasis role="bold">process definition</emphasis> of our
        business process. From such a process
        definition, we can create at runtime <emphasis role="bold">process instances</emphasis>.
        In this case, one process instance would match with the creation and verification
        of the financial report every month.
      </para>
      
      <para>
        To be able to create process instances from a given process definition,
        we must first <emphasis role="bold">deploy</emphasis> this process definition.
        Deploying a process definition means two things:
        <itemizedlist>
          <listitem>
            <para>
              The process definition will be stored in the persistent datastore that
              is configured for your Activiti engine. So by deploying our business process,
              we make sure that the engine will find the process definition after an engine reboot.
            </para>
          </listitem>
          <listitem>
            <para>
              The BPMN 2.0 process file will be parsed to an in-memory object model
              that can be manipulated through the Activiti API.
            </para>
          </listitem>
        </itemizedlist>
        More informaton on deployment can be found <link linkend="chDeployment">in the dedicated deployment section</link>.
      </para>
      
      <para>
        As described <link linkend="chDeployment">in that section</link>, deployment can happen in several
        ways. One way is through the API as follows:
        <programlisting>
Deployment deployment = processService.newDeployment()
  .addClasspathResource(&quot;org/activiti/examples/bpmn/task/financial_report_process.bpmn20.xml&quot;)
  .deploy();</programlisting>
      </para>
      
      <para>
        Now we can start a new process instance using 
        the <emphasis>id</emphasis> we defined in the process definition (see first line of the XML).
        Note that this <emphasis>id</emphasis> in Activiti terminology
        is called the <emphasis role="bold">key</emphasis>.
        <programlisting>ProcessInstance processInstance = processService.startProcessInstanceByKey(&quot;financialReport&quot;);</programlisting>
        This will create a runtime execution that
        will go first through the start event. After the start event, it follows all the outgoing
        sequence flow (only one in this case) and the first task ('write monthly financial report')
        is reached. The Activiti engine will now store a task in the persistent datastore. 
        At this point, the user or group assignments attached to the task are resolved and also stored in the 
        datastore.
      </para>
      
      <para>
        After the task is created, the <emphasis>startProcessInstanceByKey</emphasis> will return
        since the user task activity is a so-called <emphasis>'wait state'</emphasis>, which
        means that the engine will continue the process instance only when some external trigger is 
        given. In this case, the task is assigned to a group, which means that the every
        member of the group is a <emphasis role="bold">candidate</emphasis> to perform the task.
      </para>
    
    </section>
    
    <section id="bpmnFirstExampleCandidateList">
    
      <title>Task lists</title>  
      
      <para>
        We can now retrieve this newly created task through the <emphasis>taskService</emphasis>.
        <programlisting>List&lt;Task&gt; tasks = taskService.findUnassignedTasks(&quot;fozzie&quot;);</programlisting>.
        Note that the user we pass to this operation needs to be a member of 
        the <emphasis>accountancy</emphasis> group, since that was declared in the process definition:
        <programlisting>
&lt;potentialOwner&gt;
  &lt;resourceAssignmentExpression&gt;
    &lt;formalExpression&gt;<emphasis role="bold">accountancy</emphasis>&lt;/formalExpression&gt;
  &lt;/resourceAssignmentExpression&gt;
&lt;/potentialOwner&gt;</programlisting>
     
        We could also use the task query API to get the same results:
        <programlisting>List&lt;Task&gt; tasks = taskService.createTaskQuery().candidateUser(&quot;fozzie&quot;).list();</programlisting>
        or
         <programlisting>List&lt;Task&gt; tasks = taskService.createTaskQuery().candidateGroup(&quot;accountancy&quot;).list();</programlisting>
      </para>
      
      <para>
        The business process described here is also deployed as an example to the demo setup database.
        After running the <link linkend="demo.setup">demo setup</link>, log into the Activiti Explorer
        as <emphasis role="bold">fozzie</emphasis> (he's an accountant),
        and select in the drop down menu on the right the <emphasis>'Monthly financial report'</emphasis> process.
        
        <mediaobject><imageobject><imagedata align="center" fileref="images/bpmn.financial.report.example.start.process.png"/></imageobject></mediaobject>
        
        As explained, the process will execute up to the first user task. Since we're logged in
        as fozzie, we can see that there is a new candidate task available for him after we've started
        the process instance.
        Note that even if the process was started by someone else, the task would still
        be visible as a candidate task to everyone in the accountancy group.
        
        <mediaobject><imageobject><imagedata align="center" fileref="images/bpmn.financial.report.example.task.assigned.png"/></imageobject></mediaobject>
        
      </para>
      
    </section>
    
    <section id="bpmnFirstExampleClaimTask">
    
      <title>Claiming the task</title>
      
      <para>
        An accountant now needs to <emphasis role="bold">claim the task</emphasis>. By claiming the
        task, the specific user will become the <emphasis role="bold">assignee</emphasis> of the task
        and the task will dissapear from every task list of the other members of the accountancy group.
        Claiming a task is programmatically done as follows:
        <programlisting>taskService.claim(task.getId(), &quot;fozzie&quot;);</programlisting>
        The task is now in the <emphasis role="bold">personal task list of the one
        that claimed the task</emphasis>.
        <programlisting>List&lt;Task&gt; tasks = taskService.findAssignedTasks(&quot;fozzie&quot;);</programlisting>
      </para>
      
      <para>
        In the Activiti Explorer UI, clicking the <emphasis>claim</emphasis> button will
        call the same operation. The task will now move to the personal task list of the logged
        on user.
        
       <mediaobject><imageobject><imagedata align="center" fileref="images/bpmn.financial.report.example.claim.task.png"/></imageobject></mediaobject>
      </para>
      
    </section>
      
    <section id="bpmnFirstExampleCompleteTask">
    
      <title>Completing the task</title>
      
      <para>
        The accountant can now start working on the financial report. Once the report is finished,
        he can <emphasis role="bold">complete the task</emphasis>, which means that all
        work for that task is done.
        <programlisting>taskService.complete(task.getId());</programlisting>
      </para>
      
      <para>
        For the Activiti engine, this is an external signal that the process instance execution
        must be continued. The single outgoing transition out of the task is followed, bringing
        the execution in the second task (<emphasis>'verifcation of the report'</emphasis>). 
        The same mechanism as described for the first task will now
        happen, with the small difference that the task will be assigned to the 
        <emphasis>management</emphasis> group.
      </para>
      
      <para>
        In the demo setup, completing the task is done by clicking the <emphasis>complete</emphasis>
        button in the task list. Since Fozzie isn't an accountant, we need to log out of
        the Activiti Explorer and login in as <emphasis>kermit</emphasis> (which is a manager).
        The second task is now visible in the unassigned task lists.
        
        <mediaobject><imageobject><imagedata align="center" fileref="images/bpmn.financial.report.example.complete.task.png"/></imageobject></mediaobject>
      </para>
      
    </section>
      
    <section id="bpmnFirstExampleEndingProcess">

      <title>Ending the process</title>
        
      <para>
        The verification task can be retrieved and claimed in exactly the same way as before.
        Completing this second task, will bring process execution at the end event, which finishes
        the process instance. The process instance and all related runtime execution data
        is removed from the datastore.
      </para>
      
      <para>
        When you log into Activiti Probe you can verify this, since no records will be 
        found in the table where the process executions are stored.
        
         <mediaobject><imageobject><imagedata align="center" fileref="images/bpmn.financial.report.example.process.ended.png"/></imageobject></mediaobject> 
      </para>
      
    </section>
    
    <section id="bpmnFirstExampleFutureEnhancements">
    
      <title>Future enhancements</title>
      
      <para>
        It's easy to see that this business process is too simple to be useable in reality.
        However, as we are advancing in implementing process constructs, we will be able
        to enhance the business process by 
        
        <itemizedlist>
          <listitem>
            <para>
              defining a <emphasis role="bold">timer start event</emphasis> that
              automatically starts a process instance at the end of every month.
            </para>
          </listitem>
          <listitem>
            <para>
              defining <emphasis role="bold">gateways</emphasis> that act as decisions.
              This way, a manager could reject the financial report which would recreate
              the task for the accountant. 
            </para>
          </listitem>
          <listitem>
            <para>
              declaring and using <emphasis role="bold">variables</emphasis>,
              such that we can store or reference the report such that it can 
              be visualized while verifying it.
            </para>
          </listitem>
          <listitem>
            <para>
              defining a <emphasis role="bold">service task</emphasis> at the end of
              the process that will send the report to every shareholder.
            </para>
          </listitem>
          <listitem>
            <para>
              etc.
            </para>
          </listitem>
        </itemizedlist>
      </para>
    
    </section>
  	
	</section>

	<section id="bpmnConstructs">

		<title>BPMN 2.0 constructs</title>
		
			<section id="bpmnCustomExtensions">
	
	    <title>Custom extensions</title>
	
	    <para>
	      The BPMN 2.0 standard is a good thing for all parties involved. End-users don't suffer
	      from a vendor lock-in that comes by depending on a proprietary solution. Frameworks,
	      and particularly open-source frameworks such as Activiti, can implement a solution
	      that has the same (and often better implemented) features as those of a big vendor. 
	      Due to the BPMN 2.0 standard, the transition from such a big vendor solution towards
	      Activiti is an easy and smooth path.  
	    </para>
	    
	    <para>
	      The downside of a standard however, is the fact that it is always the result of 
	      many discussions and compromises between different companies (and often visions). 
	      As a developer reading the BPMN 2.0 XML of a process definition, sometimes it feels like 
	      certain constructs or way to do things are too cumbersome.
	      Since Activiti puts ease of development as a top-priority, we introduced something called the
	      <emphasis role="bold">'Activiti BPMN extensions'</emphasis>.
	      These 'extensions' are new constructs or ways to simplify certain constructs, that
	      are not in the BPMN 2.0 specification.
	    </para>
	    
	    <para>
	      Altough the BPMN 2.0 specification clearly states that it was made for custom extension,
	      we make sure that:
	      <itemizedlist>
	        <listitem>
	          <para>
	            The prerequisite of such a custom extension is that there 
	            <emphasis role="bold">always</emphasis> must be a simple tranformation to
	            the <emphasis role="bold">standard way of doing things</emphasis>.
	            So when you decide to use a custom extension, you don't have to be afraid 
	            that there is no way back.
	          </para>
	        </listitem>
	        <listitem>
	          <para>
	            When using a custom extension, this is always clearly indicated by giving
	            the new XML element, attribute, etc. the <emphasis role="bold">activiti:</emphasis> 
	            namespace prefix.
	          </para>
	        </listitem>
	        <listitem>
	          <para>
	            The goal of these extensions is to eventually push them back into a next version
	            of the BPMN specification, or at least trigger a discussion that can lead to a revision
	            of that specific BPMN construct. 
	          </para>
	        </listitem>
	      </itemizedlist> 
	    </para>
	    
	    <para>
	      So whether you want to use a custom extension or not, is completely up to you. 
	      Several factors will influence this decision (graphical editor usage, company policy, etc.).
	      We only provide them since we believe that some points in the standard can be done
	      simpler or more efficient. Feel free to give us (positive and/or negative) feedback on 
	      our extensions, or to post new ideas for custom extensions. Who knows, some day your idea
	      might pop up in the specification!.
	    </para>
	  
	  </section>
	  
	  <section id="bpmnEvents">
	   
	    <title>Events</title>
	    
	    <para>
	     Events are used to model something that happens during the lifetime process.
	     Events are always visualized as a circle.
	     
	     In BPMN 2.0, there exist
	     two main event categories: <emphasis>catching</emphasis> or <emphasis>throwing</emphasis> event.
       <itemizedlist>
         <listitem>
           <para>
             <emphasis role="bold">Catching: </emphasis>when process execution arrives in the event,
             it will wait for a trigger to happen. The type of trigger is defined by the inner icon
             or the type declaration in the XML. Catching events are visually differentiated from a 
             throwing event by the inner icon that is not filled (ie. it is white).
           </para>
         </listitem>
         <listitem>
           <para>
             <emphasis role="bold">Throwing: </emphasis>when process execution arrives in the event, a 
              trigger is fired. The type of trigger is defined by the inner icon or the type declaration
              in the XML. Throwing events are visually differentiated from a catching event by
              the inner icon that is filled with black.
           </para>
         </listitem>
       </itemizedlist>
	     
	    </para>
	   
	  </section>
	  
	  <section id="bpmnStartEvents">
	  
	   <title>Start events</title>
	  
	   <para>
	     A start event indicates where a process starts. The type of start event (process starts on receival of 
	     message, on specific time intervals, etc.), defining <emphasis>how</emphasis> the process is
	     started is shown as a small icon in the visual representation of the event. In the XML representation,
	     the type is given by the declaration of a subelement.
	   </para>
	   
	   <para>
	     Start events <emphasis role="bold">are always catching</emphasis>: conceptually
	     the event is (at any time) waiting until a certain trigger happens.
	   </para>
	  
	  </section>

		<section id="bpmnNoneStartEvent">

			<title>None start event</title>
			
			<section id="noneStartEventDescription">
       
        <title>Description</title>
        
        <para>
          A 'none' start event technically means that the trigger for starting the process instance
          is unspecified. This means that the engine cannot anticipate when the process instance must
          be started. The none start event is used when the process instance is started through the API
          by calling one of the <emphasis>startProcessInstanceByXXX</emphasis> methods.
          <programlisting>
ProcessInstance processInstance = processService.startProcessInstanceByXXX();</programlisting>
        </para>
        
        <para>
          <emphasis>Note: </emphasis> a subprocess (currently not yet implemented)
          always has a none start event.
        </para>
       
      </section>

			<section id="noneStartEventGraphicalNotation">
			 
			  <title>Graphical notation</title>
			  
			  <para>
			    A none start event is visualized as a circle with no inner icon (ie. no trigger type). 
			    <mediaobject><imageobject><imagedata align="center" fileref="images/bpmn.none.start.event.png"/></imageobject></mediaobject>
			  </para>
			 
			</section>
			
			<section id="noneStartEventXml">
       
        <title>XML representation</title>
        
        <para>
          The XML representation of a none start event is the normal
          start event declaration, without any subElement (other start event types
          all have a subElement declaring the type).
          <programlisting>
&lt;startEvent id=&quot;start&quot; name=&quot;my start event&quot; /&gt;</programlisting>
        </para>
       
      </section>

		</section>
		
		<section id="bpmnEndEvent">
		
		  <title>End events</title>
		  
		  <para>
		    An end event signifies the end (of a path) of a (sub)process. An end event is 
		    <emphasis role="bold">always throwing</emphasis>. This means that when process execution
		    arrives in the end event, a <emphasis>result</emphasis> is thrown. The type of result 
		    is depicted by the inner black icon of the event. In the XML representation,
		    the type is given by the declaration of a subelement.
		  </para>
		
		</section>

		<section id="bpmnNoneEndEvent">
		
		  <title>None end event</title>

      <section id="noneEndEventDescription">

			 <title>Description</title>
        
        <para>
          A 'none' end event means that the <emphasis>result</emphasis> thrown when
          the event is reached is unspecified. As such, the engine will not do anything
          extra besides ending the current path of execution.
        </para>
       
      </section>

      <section id="bpmnNoneEndEventDescription">
       
        <title>Graphical notation</title>
        
        <para>
          A none end event is visualized as a circle with a thick border with no inner icon (no result type).
          <mediaobject><imageobject><imagedata align="center" fileref="images/bpmn.none.end.event.png"/></imageobject></mediaobject>
        </para>
       
      </section>
      
      <section id="bpmnNoneStartEventXml">
       
        <title>XML representation</title>
        
        <para>
          The XML representation of a none end event is the normal
          end event declaration, without any subElement (other end event types
          all have a subElement declaring the type).
          <programlisting>
&lt;endEvent id=&quot;end&quot; name=&quot;my end event&quot; /&gt;</programlisting>
        </para>
       
      </section>

		</section>
		
	  <section id="bpmnSequenceFlow">
    
      <title>Sequence flow</title>
      
      <section id="sequenceFlowDescription">
      
        <title>Description</title>
        
        <para>
          A sequence flow is the connector between two elements of a process.
          After an element is visited during process execution, all outgoing sequence flow
          will be followed. This means that the default nature of BPMN 2.0 is to be parallel:
          two outgoing sequence flow will create two separate, parallel paths of execution.
        </para>
      
      </section>
      
      <section id="sequenceFlowGraphicalNotation">
      
        <title>Graphical notation</title>
        
        <para>
          A sequence flow is visualized as an arrow going from the source element towards
          the target element. The arrow always points towards the target.
          <mediaobject><imageobject><imagedata align="center" fileref="images/bpmn.sequence.flow.png"/></imageobject></mediaobject>
        </para>
      
      </section>
      
      <section id="sequenceFlowXml">
      
        <title>XML representation</title>
        
        <para>
          Sequence flow need to have a process-unique <emphasis role="bold">id</emphasis>,
          and a reference to an existing <emphasis role="bold">source</emphasis>
          and <emphasis role="bold">target</emphasis> element.
          <programlisting>
&lt;sequenceFlow id=&quot;flow1&quot; sourceRef=&quot;theStart&quot; targetRef=&quot;theTask&quot; /&gt;</programlisting>
        </para>
      
      </section>
    
    </section>
    
    <section id="bpmnConditionalSequenceFlow">
    
      <title>Conditional sequence flow</title>
      
      <section id="condSeqFlowDescription">
      
        <title>Description</title>
        
        <para>
          A sequence flow can have a condition defined on it. When a BPMN 2.0 activity
          is left, the default behaviour is to evaluate the conditions on the outgoing
          sequence flow. When a condition evaluates to <emphasis>true</emphasis>, that
          outgoing sequence flow is selected. When multiple sequence flow are selected
          that way, multiple <emphasis>tokens of execution</emphasis> will be generated
          and the process will be continued in a parallel way.
        </para>
        
        <para>
          <emphasis role="bold">Note:</emphasis> the above holds for BPMN 2.0 activities (and events),
          but not for gateways. Gateways will handle sequence flow with conditions in specific ways,
          depending on the gateway type.
        </para>
      
      </section>
      
      <section id="conditionalSequenceFlowGraphicalNotation">
      
        <title>Graphical notation</title>
        
        <para>
          A conditional sequence flow is visualized as a regular sequence flow,
          with a small diamond at the beginning. The condition expression is shown
          next to the sequence flow.
          <mediaobject><imageobject><imagedata align="center" fileref="images/bpmn.conditional.sequence.flow.png"/></imageobject></mediaobject>
        </para>
      
      </section>
      
      <section id="sequenceFlowXml">
      
        <title>XML representation</title>
        
        <para>
          A conditional sequence flow is represented in XML as a regular sequence flow,
          containing a <emphasis role="bold">conditionExpression</emphasis> sub-element.
          Note that for the moment only <emphasis>tFormalExpressions</emphasis> are supported,
          Omitting the <emphasis>xsi:type=&quot;&quot;</emphasis> definition will simply
          default to this only supported type of expressions. 
          <programlisting>&lt;sequenceFlow id=&quot;flow&quot; sourceRef=&quot;theStart&quot; targetRef=&quot;theTask&quot;&gt;
  &lt;conditionExpression xsi:type=&quot;tFormalExpression&quot;&gt;${input == 1}&lt;/conditionExpression&gt;
&lt;/sequenceFlow&gt;</programlisting>
        </para>
      
      </section>
    
    </section>
    
    <section id="bpmnGateways">
    
      <title>Gateways</title>
      
      <para>
        A gateway is used to control the flow of execution (or as the BPMN 2.0 describes,
        the <emphasis>tokens</emphasis> of execution). A gateway is capable of <emphasis>consuming</emphasis>
        or <emphasis>generating</emphasis> tokens.
      </para>
        
      <para>  
        A gateway is graphically visualized as a diamond shape, with an icon inside. 
        The icon shows the type of gateway.
         <mediaobject><imageobject><imagedata align="center" fileref="images/bpmn.gateway.png"/></imageobject></mediaobject>
      </para>
    
    </section>
    
    <section id="bpmnExclusiveGateway">
    
      <title>Exclusive gateway</title>
      
      <section id="exclusiveGatewayDescription">
      
        <title>Description</title>
        
        <para>
          An exclusive gateway (also called the <emphasis>XOR gateway</emphasis> 
          or more technical the <emphasis>exclusive data-based gateway</emphasis>),
          is used to model a <emphasis role="bold">decision</emphasis> in the proces.
          When the execution arrives at this gateway, all outgoing sequence flow are
          evaluated in the order in which they are defined. The sequence flow
          which condition evaluates to true (or which doesn't have a condition set, 
          conceptually having a <emphasis>'true'</emphasis> defined on the sequence flow)
          is selected for continuing the process. 
        </para>
        
        <para>
          <emphasis role="bold">Note:</emphasis> an exclusive gateway will never
          consume nor generate new tokens.
        </para>
      
      </section>
      
      <section id="exclusiveGatewayGraphNotation">
      
        <title>Graphical notation</title>
        
        <para>
          An exclusive gateway is visualized as a typical gateway (ie. a diamond shape)
          with an 'X' icon inside, referring to the <emphasis>XOR</emphasis> semantics.
          Note that a gateway without an icon inside defaults to an exclusive gateway.
          The BPMN 2.0 specification does not allow mixing the diamond with and without an X
          in the same process definition.
          <mediaobject><imageobject><imagedata align="center" fileref="images/bpmn.exclusive.gateway.notation.png"/></imageobject></mediaobject>
        </para>
      
      </section>
      
      <section id="exclusiveGatewayXML">
      
        <title>XML representation</title>
        
        <para>
          The XML representation of an exclusive gateway is straight-forward: one line defining
          the gateway and condition expressions defined on the outgoing sequence flow. 
          Take for example the following model:
          <mediaobject><imageobject><imagedata align="center" fileref="images/bpmn.exclusive.gateway.png"/></imageobject></mediaobject> 
          Which is represented in XML as follows:
          <programlisting>&lt;exclusiveGateway id=&quot;exclusiveGw&quot; name=&quot;Exclusive Gateway&quot; /&gt;
    
&lt;sequenceFlow id=&quot;flow2&quot; sourceRef=&quot;exclusiveGw&quot; targetRef=&quot;theTask1&quot;&gt;
  &lt;conditionExpression xsi:type=&quot;tFormalExpression&quot;&gt;${input == 1}&lt;/conditionExpression&gt;
&lt;/sequenceFlow&gt;
    
&lt;sequenceFlow id=&quot;flow3&quot; sourceRef=&quot;exclusiveGw&quot; targetRef=&quot;theTask2&quot;&gt;
  &lt;conditionExpression xsi:type=&quot;tFormalExpression&quot;&gt;${input == 2}&lt;/conditionExpression&gt;
&lt;/sequenceFlow&gt;
    
&lt;sequenceFlow id=&quot;flow4&quot; sourceRef=&quot;exclusiveGw&quot; targetRef=&quot;theTask3&quot;&gt;
  &lt;conditionExpression xsi:type=&quot;tFormalExpression&quot;&gt;${input == 3}&lt;/conditionExpression&gt;
&lt;/sequenceFlow&gt;</programlisting>
        </para>
      
      </section>
    
    </section>

		<section id="bpmnUserTask">

			<title>User task</title>

			<section id="bpmnUserTaskDescription">
			
			 <title>Description</title>
			 
			 <para>
			   A 'user task' is used to model work that needs to be done by a human actor. 
			   When process executes arrives at such a user task, a new task is created in the 
			   task list of the user(s) or group(s) assigned to that task.
			 </para>
			
			</section>
			
			<section id="bpmnUserTaskGraphicalNotation">
			
			 <title>Graphical notation</title>
			 
			 <para>
			   A user task is visualized as a typical task (rounded rectangle), with a small
			   user icon in the left upper corner.
			   <mediaobject><imageobject><imagedata align="center" fileref="images/bpmn.user.task.png"/></imageobject></mediaobject>
			 </para>
			
			</section>
			
			<section id="bpmnUserTaskXml">
			
				<title>XML representation</title>
				
				<para>
				  A user task is defined in XML as follows. The <emphasis>id</emphasis> attribute
				  is required, the <emphasis>name</emphasis> attribute is optional.
				  <programlisting>
&lt;userTask id=&quot;theTask&quot; name=&quot;Important task&quot; /&gt;			  
				  </programlisting>
				</para>
				
				<para>
			    A user task can have also a description. In fact any BPMN 2.0 element can have
				  a description, but for the moment we've only implemented it for user tasks
				  since it makes most sense there. A description is defined by adding
				  the <emphasis role="bold">documentation</emphasis> element. Note that only one
				  <emphasis>documentation</emphasis> element is supported at the moment
				  (can be multiple according to the specification).
				  <programlisting>
&lt;userTask id=&quot;theTask&quot; name=&quot;Schedule meeting&quot; &gt;
  &lt;documentation&gt;
	  Schedule an engineering meeting for next week with the new hire.
	&lt;/documentation&gt;</programlisting>
				
				  The description text can be retrieved from the task in the standard Java way:
				  <programlisting>task.getDescription()</programlisting>
				</para>
			
			</section>

			<section id="bpmnUserTaskAssignment">

				<title>User assignment</title>

				<para>
				  A user task can be directly assigned to a user. This is done by defining a
				  <emphasis role="bold">humanPerformer</emphasis> sub element.
				  Such a <emphasis>humanPerformer</emphasis> definition needs a 
				  <emphasis role="bold">resourceAssignmentExpression</emphasis> that actually defines
				  the user. Currently, only <emphasis role="bold">formalExpressions</emphasis> are supported.
				  <programlisting>
&lt;process ...
  
  ...
  
  &lt;userTask id='theTask' name='important task' &gt;
    &lt;humanPerformer&gt;
      &lt;resourceAssignmentExpression&gt;
        &lt;formalExpression&gt;kermit&lt;/formalExpression&gt;
      &lt;/resourceAssignmentExpression&gt;
    &lt;/humanPerformer&gt;
  &lt;/userTask&gt;</programlisting>
				</para>
				
				<para>
				  <emphasis role="bold">Only one</emphasis> user can be assigned as human performer to the task.
				  In Activiti terminology, this user is called the <emphasis role="bold">assignee</emphasis>.
				  Task that have an assignee are not visible in the task lists of other people, and
				  are found in the so-called <emphasis role="bold">personal task list</emphasis> of the assignee. 
				</para>
				
				<para>
				  Tasks directly assigned to users can be retrieved through the TaskService as follows:
				  <programlisting>
List&lt;Task&gt; tasks = taskService.findAssignedTasks(&quot;kermit&quot;);</programlisting>
				  Or the TaskQuery API can be used:
				  <programlisting>
List&lt;Task&gt; tasks = taskService.createTaskQuery().assignee(&quot;kermit&quot;).list();</programlisting>
          
          Both code snippets will retrieve the tasks where the assignee currently is the given user.
				</para>

        <para>
          Tasks can also be put in the so-called <emphasis role="bold">candidate task list</emphasis>
          of people. In that case, the <emphasis role="bold">potentialOwner</emphasis> construct must be used.
          The usage is similar to the <emphasis>humanPerformer</emphasis> construct. Do note that it is 
          required to define for each element in the formal expression to specify if it is
          a user or a group (the engine cannot guess this).
          <programlisting>
&lt;process ...
  
  ...
  
  &lt;userTask id='theTask' name='important task' &gt;
    &lt;potentialOwner&gt;
      &lt;resourceAssignmentExpression&gt;
        <emphasis role="bold">&lt;formalExpression&gt;user(kermit), group(management)&lt;/formalExpression&gt;</emphasis>
      &lt;/resourceAssignmentExpression&gt;
    &lt;/potentialOwner&gt;
  &lt;/userTask&gt;</programlisting>
        </para>
        
        <para>
          Tasks defines with the <emphasis>potential owner</emphasis> construct, can be retrieved as follows
          (or a similar <emphasis>TaskQuery</emphasis> usage as for the tasks with an assignee):
          <programlisting>
 List&lt;Task&gt; tasks = taskService.findUnassignedTasks(&quot;kermit&quot;);</programlisting>
          
          This will retrieve all tasks where kermit is a <emphasis role="bold">candidate user</emphasis>,
          ie. the formal expression contains <emphasis>user(kermit)</emphasis>. This will also
          retrieve all tasks that are <emphasis role="bold">assigned to a group where kermit is
          a member of</emphasis> (eg <emphasis>group(management)</emphasis>, if kermit is a member of that group).
          Note that the groups of the user are resolved at runtime and these can be 
          managed through the <emphasis>IdentityService</emphasis>.
        </para>
        
        <para>
          If no specifics are given whether the given text string is a user or group, 
          the engine defaults to group. So the following would be the same as when
          <emphasis>group(accountancy) was declared</emphasis>.
          <programlisting>
&lt;formalExpression&gt;accountancy&lt;/formalExpression&gt;</programlisting>
        </para>
        
        <section id="bpmnUserTaskUserAssignmentExtension">
          
          <title>Custom extension for simple task assignments</title>
          
          <para>
            It is clear that user and group assigmnents are quite cumbersome
            for use cases where the assignment is not complex. 
            To avoid these complexities, <link linkend="bpmnCustomExtensions">custom extensions</link>
            on the user task are possible.
          </para>
          
          <para>
            <itemizedlist>
              <listitem>
                <para>
                  <emphasis role="bold">assignee attribute</emphasis>: this custom extension allows to
                  directly assign a user task to a given user.
                  <programlisting>
&lt;userTask id=&quot;theTask&quot; name=&quot;my task&quot; activiti:assignee=&quot;kermit&quot; /&gt;</programlisting>

                  This is exactly the same as using a <emphasis role="bold">humanPerformer</emphasis> 
                  construct as defined <link linkend="bpmnUserTaskAssignment">above</link>.
                </para>
              </listitem>
              <listitem>
                <para>
                  <emphasis role="bold">candidateUsers attribute</emphasis>: this custom extension allows to
                  make a user a candidate for a task.
                  <programlisting>
&lt;userTask id=&quot;theTask&quot; name=&quot;my task&quot; activiti:candidateUsers=&quot;kermit, gonzo&quot; /&gt;</programlisting>

                  This is exactly the same as using a <emphasis role="bold">potentialOwner</emphasis> 
                  construct as defined <link linkend="bpmnUserTaskAssignment">above</link>.
                  Note that it is not required to use the <emphasis>user(kermit)</emphasis> declaration
                  as is the case with the <emphasis>potential owner</emphasis> construct, since the attribute 
                  can only be used for users.
                </para>
              </listitem>
              <listitem>
                <para>
                  <emphasis role="bold">candidateGroups attribute</emphasis>: this custom extension allows to
                  make a group a candidate for a task.
                  <programlisting>
&lt;userTask id=&quot;theTask&quot; name=&quot;my task&quot; activiti:candidateGroup=&quot;management, accountancy&quot; /&gt;</programlisting>

                  This is exactly the same as using a <emphasis role="bold">potentialOwner</emphasis> 
                  construct as defined <link linkend="bpmnUserTaskAssignment">above</link>.
                  Note that it is not required to use the <emphasis>group(management)</emphasis> declaration
                  as is the case with the <emphasis>potential owner</emphasis> construct, since the attribute 
                  can only be used for groups.
                </para>
              </listitem>
              <listitem>
                <para>
                  <emphasis>candidateUsers</emphasis> and <emphasis>candidateGroups</emphasis> can both
                  be defined on the same user task.
                </para>
              </listitem>
            </itemizedlist>
          </para>
          
        </section> <!-- task assignment extensions -->

			</section> <!-- task assignment -->

		</section> <!-- userTask -->
		
		<section id="bpmnScriptTask">
		
		  <title>Script Task</title>
		  
		  <section id="bpmnScriptTaskDescription">
		  
		    <title>Description</title>
		    
		    <para>
		      A script task is an automatic activity. When a process execution arrives at the 
		      script task, the corresponding script is executed. 
		    </para>
		  
		  </section>
		  
		  <section id="bpmnScriptTaskGraphicalNotation">
		  
		    <title>Graphical Notation</title>
		    
		    <para>
		      A script task is visualized as a typical BPMN 2.0 task (roundend rectangle),
		      with a small 'script' icon in the top-left corner of the rectangle.
		      <mediaobject><imageobject><imagedata align="center" fileref="images/bpmn.scripttask.png"/></imageobject></mediaobject>
		    </para>
		  
		  </section>
		  
		  <section id="bpmnScriptTaskXml">
		  
		    <title>XML representation</title>
		    
		    <para>
		      A script task is defined by specifying the <emphasis role="bold">script</emphasis>
		      and the <emphasis role="bold">scriptFormat</emphasis>.
<programlisting>
&lt;scriptTask id=&quot;theScriptTask&quot; name=&quot;Execute script&quot; scriptFormat=&quot;groovy&quot;&gt;
  &lt;script&gt;
    sum = 0
    for ( i in inputArray ) {
      sum += i
    }
  &lt;/script&gt;
&lt;/scriptTask&gt;</programlisting>
		    </para>
		    
		    <para>
		      The value of the <emphasis role="bold">scriptFormat</emphasis> attribute must be a
		      name that is compatible with the <ulink url="http://jcp.org/en/jsr/detail?id=223">JSR-223</ulink>
		      (scripting for the Java platform). The Groovy jar is shipped by default with the
		      Activiti distribution. If you want to use another (JSR-223 compatible) scripting
		      engine, it is sufficient to add the corresponding jar to the classpath and use
		      the appropiate name.
		    </para>
		    
		  </section>
		  
		  <section id="bpmnScriptTaskVariables">
		  
		    <title>Variables in scripts</title>
		    
		    <para>
		      All process variables that are accessible through the execution that arrives in the
		      script task, can be used within the script. In the example, the script variable
		      <emphasis>'inputArray'</emphasis> is in fact a process variable (an array of integers).
<programlisting>
&lt;script&gt;
    sum = 0
    for ( i in <emphasis role="bold">inputArray</emphasis> ) {
      sum += i
    }
&lt;/script&gt;</programlisting>
		    </para>
		    
		    <para>
		      It's also possible to set process variables in a script, simply by using an assignment
		      statement. In the example above, the <emphasis>'sum'</emphasis> variable will be
		      stored as a process variable after the script task has been executed. To avoid 
		      this behavior, script-local variables can be used. In Groovy, the keyword 
		      <emphasis>'def'</emphasis> must then be used: <emphasis>'def sum = 0'</emphasis>.
		      In that case, no process variable will be stored.
		    </para>
		    
		    <para>
		      An alternative is to set variables through the current execution, which is available
		      as a reserved variable called <emphasis>'execution'</emphasis>.
<programlisting>
&lt;script&gt;
    def scriptVar = &quot;test123&quot;
    execution.setVariable(&quot;myVar&quot;, scriptVar)
&lt;/script&gt;</programlisting>
		    </para>
		    
		    <para>
		      Note: the following names are reserved and <emphasis role="bold">cannot be used</emphasis> 
		      as variable names: <emphasis role="bold">out, out:print, lang:import, context, elcontext</emphasis>.
		    </para>
		  
		  </section>
		
		</section> <!-- scriptTask -->
		
		<section id="bpmnBoundaryEvent">
		  
		  <title>Boundary events</title>
		  
		  <para>
		    Boundary events are <emphasis>catching</emphasis> events that are attached to an activity
		    (a boundary event can never be throwing). This means that while the activity is
		    running, the event is <emphasis>listening</emphasis> for a certain type of trigger. 
		    When the event is <emphasis>catched</emphasis>, the activity is interrupted and the 
		    sequence flow going out of the event are followed.
		  </para>
		  
		  <para>
		    All boundary events are defined in the same way:
<programlisting>
&lt;boundaryEvent id=&quot;myBoundaryEvent&quot; attachedToRef=&quot;theActivity&quot;&gt;
      &lt;XXXEventDefinition/&gt;
&lt;/boundaryEvent&gt;</programlisting>
		  </para>
		  
		  <para>
		    A boundary event is defined with
		    <itemizedlist>
		      <listitem>
		        <para>
		          A unique identifier (process-wide)
		        </para>
		      </listitem>
		      <listitem>
		        <para>
		          A reference to the activity to which the event is attached through the
		          <emphasis role="bold">attachedToRef</emphasis> attribute.
		          Note that a boundary event is defined on the same level as the activities
		          to which they are attached
		          (ie. no inclusion of the boundary event inside the activity).
		        </para>
		      </listitem>
		      <listitem>
		        <para>
		          An XML subelement of the form <emphasis>XXXEventDefinition</emphasis> 
		          (eg. <emphasis>TimerEventDefinition</emphasis>, <emphasis>ErrorEventDefinition</emphasis>, etc.)
		          defining the type of the boundary event. See the specific boundary event types
		          for more details.
		        </para>
		      </listitem>
		    </itemizedlist>
		  </para>
		  
		</section> <!-- Boundary event -->
		  
		<section id="bpmnTimerBoundaryEvent">
      
      <title>Timer Boundary Event</title>
        
      <section id="timerBoundaryEventDescription">
        
        <title>Description</title>
          
        <para>
          A timer boundary event acts as a stopwatch and alarm clock. When an execution arrives
          in the activity where the boundary event is attached to, a timer is started.
          When the timer fires (eg. after a specified interval), the activity is interrupted
          and the sequence flow going out of the timer boundary event are followed.
        </para>
        
      </section>
        
      <section id="bpmnTimerBoundaryEventGraphicalNotation">
        
        <title>Graphical Notation</title>
          
        <para>
          A timer boundary event is visualized as a typical boundary event (ie. circle
          on the border), with the timer icon on the inside.
          <mediaobject><imageobject><imagedata align="center" fileref="images/bpmn.boundary.timer.event.png"/></imageobject></mediaobject>
        </para>
        
      </section>
      
      <section id="bpmnTimerBoundaryEventXml">
      
        <title>XNL Representation</title>
        
        <para>
          A timer boundary event is defined as a <link linkend="bpmnBoundaryEvent">regular boundary event</link>.
          The specific type subelement is in this case a <emphasis role="bold">timerEventDefinition</emphasis>
          element.
<programlisting>
&lt;boundaryEvent id=&quot;escalationTimer&quot; cancelActivity=&quot;true&quot; attachedToRef=&quot;firstLineSupport&quot;&gt;
   <emphasis role="bold">&lt;timerEventDefinition&gt;
    &lt;timeDuration&gt;PT4H&lt;/timeDuration&gt;
  &lt;/timerEventDefinition&gt;</emphasis>
&lt;/boundaryEvent&gt;          
</programlisting>
        </para>
        
        <para>
          To specify how long the timer should run before it is fired, a <emphasis>timeDuration</emphasis>
          can be specified as subelement of <emphasis>timerEventDefinition</emphasis>. The format
          used is the <ulink url="http://en.wikipedia.org/wiki/ISO_8601#Durations">ISO 8601</ulink>
          format (as required by the BPMN 2.0 specification).
        </para>
      
      </section>
		
		</section> <!-- timer boundary event -->

	</section> <!-- bpmnConstructs -->

</chapter>
